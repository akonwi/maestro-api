use ard/decode
use ard/sqlite

struct Bet {
  id: Int,
  match_id: Int,
  name: Str,
  amount: Float,
  line: Float,
  odds: Int,
  result: Str,
}

fn get_all(db: sqlite::Database) [Bet]!Str {
  match db.get<Bet>(table: "bets", where: "") {
    err => Result::err(err),
    ok(bs) => Result::ok(bs)
  }
}

fn get_payout(bet: Bet) Float {
  // Positive odds: +150 means bet $100 to win $150
  // Negative odds: -150 means bet $150 to win $100
	match bet.odds > 0 {
	  true => bet.amount + (bet.amount * Float::from_int(bet.odds) / 100.0),
	  false => bet.amount + (bet.amount * 100.0 / Float::from_int(-bet.odds))
	}
}

struct Overview {
  bets: [Bet],
  num_pending: Int,
  total_wagered: Float,
  win_rate: Float,
  gross_payout: Float,
  net_profit:     Float,
  gross_loss:   Float,
  roi: Float,
}

// todo: most of this can be done with sql
private fn compute(bets: [Bet], total_wagered: Float, wins: Int, losses: Int, num_pending: Int, gross_payout: Float, gross_loss: Float) Overview {
  let settled = wins + losses
  let net_profit = gross_payout - gross_loss
  let roi = (net_profit/total_wagered) * 100.0

  Overview{
    bets: bets,
    total_wagered: total_wagered,
    num_pending: num_pending,
    win_rate: (Float::from_int(wins) / Float::from_int(settled)) * 100.0,
    gross_payout: gross_payout,
    gross_loss: gross_loss,
    net_profit: net_profit,
    roi: roi,
  }
}

fn get_overview(db: sqlite::Database) Overview!Str {
  let amount_data = try db.query("SELECT COALESCE(SUM(amount), 0) as value FROM bets")
  let total_wagered = try decode::run(amount_data, decode::field("value", decode::float)) -> errs {
    Result::err("Failed to sum total bet amount. Expected {errs.at(0).expected} {errs.at(0).found}")
  }

  let wins_data = try db.query("SELECT COUNT(*) FROM bets WHERE result = 'win'")
  let wins = try decode::run(wins_data, decode::int) -> errs {
    Result::err("Failed to count wins. Got {errs.at(0).found}")
  }

  let losses_data = try db.query("SELECT COUNT(*) FROM bets WHERE result = 'lose'")
  let losses = try decode::run(losses_data, decode::int) -> errs {
    Result::err("Failed to count losses. Got {errs.at(0).found}")
  }

  let pending_data = try db.query("SELECT COUNT(*) FROM bets WHERE result = 'pending'")
  let num_pending = try decode::run(pending_data, decode::int) -> errs {
    Result::err("Failed to count pending bets. Got {errs.at(0).found}")
  }

  // Calculate total payout
	let	winning_bet_rows = try db.query("SELECT amount, odds FROM bets WHERE result = 'win'")

	let payouts = try decode::run(winning_bet_rows, decode::list(fn(data: decode::Dynamic) Float![decode::Error] {
	  let amount = try decode::run(data, decode::field("amount", decode::float))
	  let odds = try decode::run(data, decode::field("odds", decode::int))

		// Positive odds: +150 means bet $100 to win $150
		// Negative odds: -150 means bet $150 to win $100
		let payout = match odds > 0 {
		  true => amount + (amount * Float::from_str(odds.to_str()).or(0.0) / 100.0),
			false => amount + (amount * 100.0 / -Float::from_str(odds.to_str()).or(0.0))
		}
		Result::ok(payout)
	})) -> errs {
	  Result::err("Failed to calculate total payout. Expected {errs.at(0).expected}, Got {errs.at(0).found}")
	}

	mut gross_payout = 0.0
	for p in payouts {
	  gross_payout =+ p
	}

	// Get total losses (losing bets amount)
	let loss_amount_data = try db.query("SELECT COALESCE(SUM(amount), 0) FROM bets WHERE result = 'lose'")
	let gross_loss = try decode::run(loss_amount_data, decode::float) -> errs {
	  Result::err("Failed to calculate total loss. Expected {errs.at(0).expected}, Got {errs.at(0).found}")
	}

	let settled = wins + losses
  let net_profit = gross_payout - gross_loss
  let roi = (net_profit/total_wagered) * 100.0

  let bets = try get_all(db)

  Result::ok(Overview{
    bets: bets,
    total_wagered: total_wagered,
    num_pending: num_pending,
    win_rate: (Float::from_int(wins) / Float::from_int(settled)) * 100.0,
    gross_payout: gross_payout,
    gross_loss: gross_loss,
    net_profit: net_profit,
    roi: roi,
  })
}
