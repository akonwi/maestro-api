use ard/env
use ard/decode
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct Team {
  id: Int,
	name: Str,
	code: Str?,
	league_id: Int,
}

fn decode_team(data: decode::Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let code = try decode::run(data, decode::field("code", decode::nullable(decode::string)))
  let league_id = try decode::run(data, decode::field("league_id", decode::int))

  Result::ok(Team {
    id: id,
    name: name,
    code: code,
    league_id: league_id,
  })
}

struct TeamEntryTeam {
	id: Int,
	name: Str,
	code: Str?,
}

struct TeamEntry {
  team: TeamEntryTeam
}

struct TeamsResponse {
  errors: [Str],
  results: Int,
  response: [TeamEntry],
}

private fn parse_teams(res: http::Response) [TeamEntryTeam] {
  match res.json<TeamsResponse>() {
    err => {
      io::print("Unable to parse teams response: {err}")
      List::new<TeamEntryTeam>()
    },
    ok(response) => {
      io::print("Received {response.results} results")
      mut teams = List::new<TeamEntryTeam>()
      for entry in response.response {
        teams.push(entry.team)
      }
      teams
    },
  }
}

fn fetch(league_id: Int, season: Int) [Team] {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }

  mut result: [Team] = []

  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/teams?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
    body: maybe::none(),
  }

  match http::send(req) {
    err => {
      io::print("Error fetching teams: {err}")
    },
    ok(res) => {
      let entries = parse_teams(res)
      for entry in entries {
        result.push(Team{
          id: entry.id,
          name: entry.name,
          code: entry.code,
          league_id: league_id,
        })
      }
    },
  }

  result
}

fn decode_team(row: decode::Dynamic) Team![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let league_id = try decode::run(row, decode::field("league_id", decode::int))
  let name = try decode::run(row, decode::field("name", decode::string))
  let code = try decode::run(row, decode::field("code", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    league_id: league_id,
    name: name,
    code: code,
  })
}

fn get_all(db: sqlite::Database) [Team]!Str {
  let rows = try db.query("select * from teams")
  let teams = try decode::run(rows, decode::list(decode_team)) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(teams)
}

// return a map of id to name
fn get_in_matches(db: sqlite::Database, ids: [Int]) [Int:Str]!Str {
  mut ids_string = ""
  for id, i in ids {
    if i == 0 {
      ids_string = id.to_str()
    } else {
      ids_string = "{ids_string},{id}"
    }
  }
  let rows = try db.query("
    select t.id, t.name from teams t
    join matches m on m.home_team_id = t.id or m.away_team_id = t.id
    where m.id in ({ids_string});
  ")

  struct Row { id: Int, name: Str }
  let decode_row = fn(row: decode::Dynamic) Row![decode::Error] {
    let id = try decode::run(row, decode::field("id", decode::int))
    let name = try decode::run(row, decode::field("name", decode::string))
    Result::ok(Row{id:id, name:name})
  }

  let entries = try decode::run(rows, decode::list(decode_row)) -> errors {
    mut msg = ""
    for e in errors {
      msg = "{msg}, {e.to_str()}"
    }
    Result::err(msg)
  }

  mut id_to_name: [Int:Str] = [:]
  for entry in entries {
    id_to_name.set(entry.id, entry.name)
  }

  Result::ok(id_to_name)
}

struct Snapshot {
	id: Int,
	name: Str,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,

	cleansheets: Int,
	one_conceded: Int,
	two_plus_conceded: Int,
}

struct Comparison {
  home: Snapshot,
  away: Snapshot,
}

fn get_snapshot(db: sqlite::Database, id: Int) Snapshot!Str {
	let wins = try db.count("matches", "winner_id = {id}")
	let losses = try db.count("matches", "
	  (home_team_id = {id} OR away_team_id = {id})
		and status = 'FT'
		and winner_id is not null
		and winner_id != {id}"
	)
	let draws = try db.count("matches", "
	  (home_team_id = {id} OR away_team_id = {id})
		and status = 'FT'
		and winner_id is null"
	)
	let team_row = try db.first("select name from teams where id = {id}")
	let name = try decode::run(team_row, decode::field("name", decode::string)) -> errs {
	  Result::err("Unable to decode team name: {errs.at(0)}")
	}

	let home_goals_for_raw = try db.first(
	  "SELECT COALESCE(SUM(home_goals), 0) as value FROM matches
		where home_team_id = {id} and status = 'FT'"
	)
	let home_goals_for = try decode::run(home_goals_for_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode home goals for: {errs.at(0)}")
	}
	let away_goals_for_raw = try db.first(
	  "SELECT COALESCE(SUM(away_goals), 0) as value FROM matches
		where away_team_id = {id} and status = 'FT'"
	)
	let away_goals_for = try decode::run(away_goals_for_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode away goals for: {errs.at(0)}")
	}

	let home_goals_against_raw = try db.first(
	  "SELECT COALESCE(SUM(away_goals), 0) as value FROM matches
		where home_team_id = {id} and status = 'FT'"
	)
	let home_goals_against = try decode::run(home_goals_against_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode home goals against: {errs.at(0)}")
	}
	let away_goals_against_raw = try db.first(
	  "SELECT COALESCE(SUM(home_goals), 0) as value FROM matches
		where away_team_id = {id} and status = 'FT'"
	)
	let away_goals_against = try decode::run(away_goals_against_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode away goals against: {errs.at(0)}")
	}

	let cleansheets = try db.count("matches",
	  "status = 'FT'
		and (
		  (home_team_id = {id} and away_goals = 0)
			OR (away_team_id = {id} and home_goals = 0)
		)"
	)
	let one_conceded = try db.count("matches",
	  "status = 'FT'
		and (
		  (home_team_id = {id} and away_goals = 1)
			OR (away_team_id = {id} and home_goals = 1)
		)"
	)
	let total_games = wins + losses + draws
	let two_plus_conceded = total_games - cleansheets - one_conceded

	Result::ok(Snapshot{
	  id: id,
		name: name,
	  wins: wins,
		losses: losses,
		draws: draws,
		goals_for: home_goals_for + away_goals_for,
		goals_against: home_goals_against + away_goals_against,
		cleansheets: cleansheets,
		one_conceded: one_conceded,
		two_plus_conceded: two_plus_conceded,
	})
}

fn get_comparison(db: sqlite::Database, home_id: Int, away_id: Int) Comparison!Str {
  let home = try get_snapshot(db, home_id)
  let away = try get_snapshot(db, away_id)
  Result::ok(Comparison{
    home: home,
    away: away,
  })
}
