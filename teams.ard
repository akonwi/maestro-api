use ard/env
use ard/decode
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct Team {
  id: Int,
	name: Str,
	code: Str?,
	league_id: Int,
}

fn decode_team(data: decode::Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let code = try decode::run(data, decode::field("code", decode::nullable(decode::string)))
  let league_id = try decode::run(data, decode::field("league_id", decode::int))

  Result::ok(Team {
    id: id,
    name: name,
    code: code,
    league_id: league_id,
  })
}

struct TeamEntryTeam {
	id: Int,
	name: Str,
	code: Str?,
}

struct TeamEntry {
  team: TeamEntryTeam
}

struct TeamsResponse {
  errors: [Str],
  results: Int,
  response: [TeamEntry],
}

private fn parse_teams(res: http::Response) [TeamEntryTeam] {
  match res.json<TeamsResponse>() {
    err => {
      io::print("Unable to parse teams response: {err}")
      List::new<TeamEntryTeam>()
    },
    ok(response) => {
      io::print("Received {response.results} results")
      mut teams = List::new<TeamEntryTeam>()
      for entry in response.response {
        teams.push(entry.team)
      }
      teams
    },
  }
}

fn fetch(league_id: Int, season: Int) [Team] {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }

  mut result: [Team] = []

  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/teams?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
    body: maybe::none(),
  }

  match http::send(req) {
    err => {
      io::print("Error fetching teams: {err}")
    },
    ok(res) => {
      let entries = parse_teams(res)
      for entry in entries {
        result.push(Team{
          id: entry.id,
          name: entry.name,
          code: entry.code,
          league_id: league_id,
        })
      }
    },
  }

  result
}

fn decode_team(row: decode::Dynamic) Team![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let league_id = try decode::run(row, decode::field("league_id", decode::int))
  let name = try decode::run(row, decode::field("name", decode::string))
  let code = try decode::run(row, decode::field("code", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    league_id: league_id,
    name: name,
    code: code,
  })
}

fn get_all(db: sqlite::Database) [Team]!Str {
  let rows = try db.query("select * from teams")
  let teams = try decode::run(rows, decode::list(decode_team)) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(teams)
}

// return a map of id to name
fn get_in_matches(db: sqlite::Database, ids: [Int]) [Int:Str]!Str {
  mut ids_string = ""
  for id, i in ids {
    if i == 0 {
      ids_string = id.to_str()
    } else {
      ids_string = "{ids_string},{id}"
    }
  }
  let rows = try db.query("
    select t.id, t.name from teams t
    join matches m on m.home_team_id = t.id or m.away_team_id = t.id
    where m.id in ({ids_string});
  ")

  struct Row { id: Int, name: Str }
  let decode_row = fn(row: decode::Dynamic) Row![decode::Error] {
    let id = try decode::run(row, decode::field("id", decode::int))
    let name = try decode::run(row, decode::field("name", decode::string))
    Result::ok(Row{id:id, name:name})
  }

  let entries = try decode::run(rows, decode::list(decode_row)) -> errors {
    mut msg = ""
    for e in errors {
      msg = "{msg}, {e.to_str()}"
    }
    Result::err(msg)
  }

  mut id_to_name: [Int:Str] = [:]
  for entry in entries {
    id_to_name.set(entry.id, entry.name)
  }

  Result::ok(id_to_name)
}
