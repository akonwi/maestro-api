use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct FixtureEntryFixtureStatus {
  short: Str,
}

struct FixtureEntryFixture {
  id: Int,
  date: Str,
  timestamp: Int,
  status: FixtureEntryFixtureStatus,
}

struct FixtureEntryGoals {
  home: Int?,
  away: Int?,
}

struct FixtureTeam {
  id: Int,
  name: Str,
  winner: Bool?,
}

struct FixtureEntryTeams {
  home: FixtureTeam,
  away: FixtureTeam,
}

struct FixtureEntryLeague {
  id: Int
}

struct FixtureEntry {
  fixture: FixtureEntryFixture,
  goals: FixtureEntryGoals,
  league: FixtureEntryLeague,
  teams: FixtureEntryTeams,
}

struct FixturesResponse {
  // errors: [Str],
  results: Int,
  response: [FixtureEntry],
}

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league_id: Int,
  status: Str,
  home_team_id: Int,
  away_team_id: Int,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

fn init_db(db: sqlite::Database) {
  db.exec(
    "CREATE TABLE IF NOT EXISTS matches (
      id INTEGER PRIMARY KEY,
      date TEXT NOT NULL,
      timestamp INTEGER NOT NULL,
      league_id INTEGER NOT NULL,
      status TEXT NOT NULL,
      home_team_id INTEGER NOT NULL,
      away_team_id INTEGER NOT NULL,
      home_goals INTEGER NOT NULL,
      away_goals INTEGER NOT NULL,
      winner_id INTEGER
    )"
  ).expect("Failed to create matches table")
}

fn fetch_fixture(id: Int) Match? {
  io::print("fetching {id}")
  let req = http::Request{
    method: "GET",
    url: "https://v3.football.api-sports.io/fixtures?id={id}",
    headers: [
      "x-rapidapi-key": "91be9b12c36d01fd71847355d020c8d7",
      "Accept": "application/json",
    ],
    body: maybe::none(),
  }

  match http::send(req) {
    err => {
      io::print("Error fetching fixture: {err}")
      maybe::none()
    },
    ok(res) => {
      let entries = match res.json<FixturesResponse>() {
        err => {
          io::print("Error parsing fixtures: {err}")
          List::new<FixtureEntry>()
        },
        ok(data) => data.response
      }

      if not entries.size() == 1 {
        panic("Expected exactly one fixture and got {entries.size()}")
      }

      let entry = entries.at(0)
      mut winner_id: Int? = maybe::none()
      if entry.teams.home.winner.or(false) {
        winner_id = maybe::some(entry.teams.home.id)
      } else if entry.teams.away.winner.or(false) {
        winner_id = maybe::some(entry.teams.away.id)
      }

      maybe::some(Match{
        id: entry.fixture.id,
        date: entry.fixture.date,
        timestamp: entry.fixture.timestamp,
        league_id: entry.league.id,
        status: entry.fixture.status.short,
        home_team_id: entry.teams.home.id,
        away_team_id: entry.teams.away.id,
        home_goals: entry.goals.home.or(0),
        away_goals: entry.goals.away.or(0),
        winner_id: winner_id,
      })
    }
  }
}

fn update_match(db: sqlite::Database, m: Match) {
  match db.update("matches", "id={m.id}", m) {
    ok => io::print("Updated match {m.id}"),
    err => io::print("Error updating match {m.id}: {err}"),
  }
}

fn update_fixtures(db: sqlite::Database) {
  let pending_fixtures = db.get<Match>("matches", "status != 'FT'")
  match pending_fixtures {
    err => io::print("Error finding pending fixtures: {err}"),
    ok(fixtures) => {
      for f in fixtures {
        match fetch_fixture(f.id) {
          m => update_match(db, m),
          _ => io::print("Fixture not found: {f.id}")
        }
      }
    }
  }
}

// fn fetch_season(league_id: Int, season: Int) [Match] {
//   let req = http::Request{
//     method: "GET",
//     url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={season}",
//     headers: [
//       "x-rapidapi-key": "91be9b12c36d01fd71847355d020c8d7",
//       "Accept": "application/json",
//     ],
//     body: maybe::none(),
//   }

//   match http::send(req) {
//     err => {
//       io::print("Error fetching fixtures: {err}")
//       List::new<Match>()
//     },
//     ok(res) => {
//       let entries = match res.json<FixturesResponse>() {
//         err => {
//           io::print("Error parsing fixtures: {err}")
//           List::new<FixtureEntry>()
//         },
//         ok(data) => data.response
//       }

//       mut result: [Match] = []

//       for entry in entries {
//         mut winner_id: Int? = maybe::none()
//         if entry.teams.home.winner.or(false) {
//           winner_id = maybe::some(entry.teams.home.id)
//         } else if entry.teams.away.winner.or(false) {
//           winner_id = maybe::some(entry.teams.away.id)
//         }

//         result.push(Match{
//           id: entry.fixture.id,
//           date: entry.fixture.date,
//           timestamp: entry.fixture.timestamp,
//           league_id: league_id,
//           status: entry.fixture.status.short,
//           home_team_id: entry.teams.home.id,
//           away_team_id: entry.teams.away.id,
//           home_goals: entry.goals.home.or(0),
//           away_goals: entry.goals.away.or(0),
//           winner_id: winner_id,
//         })
//       }

//       result
//     }
//   }
// }

// // seed the db with completed matches in 2025
// // todo: accept season parameter
// fn seed_db(db: sqlite::Database, league_ids: [Int]) {
//   for id in league_ids {
//     for m in fetch_season(id, 2025) {
//       let exists = db.exists("matches", "id = {m.id}").expect("Error checking for match in db")
//       if (not exists) {
//         match db.insert("matches", m) {
//           err => io::print("Error inserting match({m.id}): {err}"),
//           ok => {},
//         }
//       } else {
//         match db.update("matches", "id={m.id}", m) {
//           err => io::print("Error updating match({m.id}): {err}"),
//           ok => {},
//         }
//       }
//     }

//     io::print("Updated matches")
//   }
// }
