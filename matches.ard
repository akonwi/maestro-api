use ard/decode
use ard/env
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct FixtureEntryFixtureStatus {
  short: Str,
}

struct FixtureEntryFixture {
  id: Int,
  date: Str,
  timestamp: Int,
  status: FixtureEntryFixtureStatus,
}

struct FixtureEntryGoals {
  home: Int?,
  away: Int?,
}

struct FixtureTeam {
  id: Int,
  name: Str,
  winner: Bool?,
}

struct FixtureEntryTeams {
  home: FixtureTeam,
  away: FixtureTeam,
}

struct FixtureEntryLeague {
  id: Int
}

struct FixtureEntry {
  fixture: FixtureEntryFixture,
  goals: FixtureEntryGoals,
  league: FixtureEntryLeague,
  teams: FixtureEntryTeams,
}

struct FixturesResponse {
  // errors: [Str],
  results: Int,
  response: [FixtureEntry],
}

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league_id: Int,
  status: Str,
  home_team_id: Int,
  away_team_id: Int,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

fn fetch_season(league_id: Int, season: Int) [Match] {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  }

  mut matches = List::new<Match>()

  match http::send(req) {
    err => io::print("Error fetching fixtures: {err}"),
    ok(res) => {
      let entries = match res.json<FixturesResponse>() {
        err => {
          io::print("Error parsing fixtures: {err}")
          List::new<FixtureEntry>()
        },
        ok(data) => data.response
      }

      for entry in entries {
        mut winner_id: Int? = maybe::none()
        if entry.teams.home.winner.or(false) {
          winner_id = maybe::some(entry.teams.home.id)
        } else if entry.teams.away.winner.or(false) {
          winner_id = maybe::some(entry.teams.away.id)
        }

        matches.push(Match{
          id: entry.fixture.id,
          date: entry.fixture.date,
          timestamp: entry.fixture.timestamp,
          league_id: league_id,
          status: entry.fixture.status.short,
          home_team_id: entry.teams.home.id,
          away_team_id: entry.teams.away.id,
          home_goals: entry.goals.home.or(0),
          away_goals: entry.goals.away.or(0),
          winner_id: winner_id,
        })
      }
    }
  }

  matches
}

fn fetch_fixture(id: Int) Match? {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?id={id}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  }

  match http::send(req) {
    err => {
      io::print("Error fetching fixture: {err}")
      maybe::none()
    },
    ok(res) => {
      let entries = match res.json<FixturesResponse>() {
        err => {
          io::print("Error parsing fixtures: {err}")
          List::new<FixtureEntry>()
        },
        ok(data) => data.response
      }

      if not entries.size() == 1 {
        panic("Expected exactly one fixture and got {entries.size()}")
      }

      let entry = entries.at(0)
      mut winner_id: Int? = maybe::none()
      if entry.teams.home.winner.or(false) {
        winner_id = maybe::some(entry.teams.home.id)
      } else if entry.teams.away.winner.or(false) {
        winner_id = maybe::some(entry.teams.away.id)
      }

      maybe::some(Match{
        id: entry.fixture.id,
        date: entry.fixture.date,
        timestamp: entry.fixture.timestamp,
        league_id: entry.league.id,
        status: entry.fixture.status.short,
        home_team_id: entry.teams.home.id,
        away_team_id: entry.teams.away.id,
        home_goals: entry.goals.home.or(0),
        away_goals: entry.goals.away.or(0),
        winner_id: winner_id,
      })
    }
  }
}

fn update_match(db: sqlite::Database, m: Match) {
  match db.update("matches", "id={m.id}", m) {
    ok => {},
    err => io::print("Error updating match {m.id}: {err}"),
  }
}

// MLS
let league_ids = [253]

// update the matches in the db
fn sync(db: sqlite::Database) {
  for id in league_ids {
    for m in fetch_season(id, 2025) {
      let exists = db.exists("matches", "id = {m.id}").expect("Error checking for match in db")
      if exists {
        match db.update("matches", "id={m.id}", m) {
          err => io::print("Error updating match({m.id}): {err}"),
          ok => {},
        }
      } else {
        match db.insert("matches", m) {
          err => io::print("Error inserting match({m.id}): {err}"),
          ok => {},
        }
      }
    }

    io::print("Updated match data for league {id}")
  }
}

fn get_league(db: sqlite::Database, league_id: Int) [Match]!Str {
  db.get<Match>(table: "matches", where: "league_id = {league_id}")
}

private fn ints_to_str(ints: [Int]) Str {
  mut str = ""
  for int, idx in ints {
    if idx == 0 {
      str = int.to_str()
    } else {
      str = "{str},{int}"
    }
  }
  str
}

fn decode_match(row: decode::Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let date = try decode::run(row, decode::field("date", decode::string))
  let timestamp = try decode::run(row, decode::field("timestamp", decode::int))
  let league_id = try decode::run(row, decode::field("league_id", decode::int))
  let status = try decode::run(row, decode::field("status", decode::string))
  let home_team_id = try decode::run(row, decode::field("home_team_id", decode::int))
  let away_team_id = try decode::run(row, decode::field("away_team_id", decode::int))
  let home_goals = try decode::run(row, decode::field("home_goals", decode::int))
  let away_goals = try decode::run(row, decode::field("away_goals", decode::int))
  let winner_id = try decode::run(row, decode::field("winner_id", decode::nullable(decode::int)))

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    away_team_id: away_team_id,
    home_goals: home_goals,
    away_goals: away_goals,
    winner_id: winner_id,
  })
}

fn get(db: sqlite::Database, ids: [Int]) [Match]!Str {
  let rows = try db.query("select * from matches where id in ({ints_to_str(ids)});")
  let matches = try decode::run(rows, decode::list(decode_match)) -> errors {
    Result::err(errors.at(0).to_str())
  }
  Result::ok(matches)
}
