use ard/env
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct FixtureEntryFixtureStatus {
  short: Str,
}

struct FixtureEntryFixture {
  id: Int,
  date: Str,
  timestamp: Int,
  status: FixtureEntryFixtureStatus,
}

struct FixtureEntryGoals {
  home: Int?,
  away: Int?,
}

struct FixtureTeam {
  id: Int,
  name: Str,
  winner: Bool?,
}

struct FixtureEntryTeams {
  home: FixtureTeam,
  away: FixtureTeam,
}

struct FixtureEntryLeague {
  id: Int
}

struct FixtureEntry {
  fixture: FixtureEntryFixture,
  goals: FixtureEntryGoals,
  league: FixtureEntryLeague,
  teams: FixtureEntryTeams,
}

struct FixturesResponse {
  // errors: [Str],
  results: Int,
  response: [FixtureEntry],
}

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league_id: Int,
  status: Str,
  home_team_id: Int,
  away_team_id: Int,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

fn init_db(db: sqlite::Database) {
  db.exec(
    "CREATE TABLE IF NOT EXISTS matches (
      id INTEGER PRIMARY KEY,
      date TEXT NOT NULL,
      timestamp INTEGER NOT NULL,
      league_id INTEGER NOT NULL,
      status TEXT NOT NULL,
      home_team_id INTEGER NOT NULL,
      away_team_id INTEGER NOT NULL,
      home_goals INTEGER NOT NULL,
      away_goals INTEGER NOT NULL,
      winner_id INTEGER
    )"
  ).expect("Failed to create matches table")
}

fn fetch_season(league_id: Int, season: Int) [Match] {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  }

  mut matches = List::new<Match>()

  match http::send(req) {
    err => io::print("Error fetching fixtures: {err}"),
    ok(res) => {
      let entries = match res.json<FixturesResponse>() {
        err => {
          io::print("Error parsing fixtures: {err}")
          List::new<FixtureEntry>()
        },
        ok(data) => data.response
      }

      for entry in entries {
        mut winner_id: Int? = maybe::none()
        if entry.teams.home.winner.or(false) {
          winner_id = maybe::some(entry.teams.home.id)
        } else if entry.teams.away.winner.or(false) {
          winner_id = maybe::some(entry.teams.away.id)
        }

        matches.push(Match{
          id: entry.fixture.id,
          date: entry.fixture.date,
          timestamp: entry.fixture.timestamp,
          league_id: league_id,
          status: entry.fixture.status.short,
          home_team_id: entry.teams.home.id,
          away_team_id: entry.teams.away.id,
          home_goals: entry.goals.home.or(0),
          away_goals: entry.goals.away.or(0),
          winner_id: winner_id,
        })
      }
    }
  }

  matches
}

fn fetch_fixture(id: Int) Match? {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?id={id}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  }

  match http::send(req) {
    err => {
      io::print("Error fetching fixture: {err}")
      maybe::none()
    },
    ok(res) => {
      let entries = match res.json<FixturesResponse>() {
        err => {
          io::print("Error parsing fixtures: {err}")
          List::new<FixtureEntry>()
        },
        ok(data) => data.response
      }

      if not entries.size() == 1 {
        panic("Expected exactly one fixture and got {entries.size()}")
      }

      let entry = entries.at(0)
      mut winner_id: Int? = maybe::none()
      if entry.teams.home.winner.or(false) {
        winner_id = maybe::some(entry.teams.home.id)
      } else if entry.teams.away.winner.or(false) {
        winner_id = maybe::some(entry.teams.away.id)
      }

      maybe::some(Match{
        id: entry.fixture.id,
        date: entry.fixture.date,
        timestamp: entry.fixture.timestamp,
        league_id: entry.league.id,
        status: entry.fixture.status.short,
        home_team_id: entry.teams.home.id,
        away_team_id: entry.teams.away.id,
        home_goals: entry.goals.home.or(0),
        away_goals: entry.goals.away.or(0),
        winner_id: winner_id,
      })
    }
  }
}

fn update_match(db: sqlite::Database, m: Match) {
  match db.update("matches", "id={m.id}", m) {
    ok => {},
    err => io::print("Error updating match {m.id}: {err}"),
  }
}

// MLS
let league_ids = [253]

// update the matches in the db
fn sync(db: sqlite::Database) {
  for id in league_ids {
    for m in fetch_season(id, 2025) {
      let exists = db.exists("matches", "id = {m.id}").expect("Error checking for match in db")
      if exists {
        match db.update("matches", "id={m.id}", m) {
          err => io::print("Error updating match({m.id}): {err}"),
          ok => {},
        }
      } else {
        match db.insert("matches", m) {
          err => io::print("Error inserting match({m.id}): {err}"),
          ok => {},
        }
      }
    }

    io::print("Updated match data for league {id}")
  }
}

fn get_league(db: sqlite::Database, league_id: Int) [Match]!Str {
  db.get<Match>(table: "matches", where: "league_id = {league_id}")
}
