use ard/decode
use ard/env
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league_id: Int,
  status: Str,
  home_team_id: Int,
  away_team_id: Int,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

fn decode_match(row: decode::Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let date = try decode::run(row, decode::field("date", decode::string))
  let timestamp = try decode::run(row, decode::field("timestamp", decode::int))
  let league_id = try decode::run(row, decode::field("league_id", decode::int))
  let status = try decode::run(row, decode::field("status", decode::string))
  let home_team_id = try decode::run(row, decode::field("home_team_id", decode::int))
  let away_team_id = try decode::run(row, decode::field("away_team_id", decode::int))
  let home_goals = try decode::run(row, decode::field("home_goals", decode::int))
  let away_goals = try decode::run(row, decode::field("away_goals", decode::int))
  let winner_id = try decode::run(row, decode::field("winner_id", decode::nullable(decode::int)))

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    away_team_id: away_team_id,
    home_goals: home_goals,
    away_goals: away_goals,
    winner_id: winner_id,
  })
}

// fixtures come from API-Football
fn decode_fixture_entry(row: decode::Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("fixture", decode::field("id", decode::int)))
  let date = try decode::run(row, decode::field("fixture", decode::field("date", decode::string)))
  let timestamp = try decode::run(row, decode::field("fixture", decode::field("timestamp", decode::int)))
  let status = try decode::run(row, decode::field("fixture", decode::field("status", decode::field("short", decode::string))))
  let league_id = try decode::run(row, decode::field("league", decode::field("id", decode::int)))
  let home_team_id = try decode::run(row, decode::field("teams", decode::field("home", decode::field("id", decode::int))))
  let away_team_id = try decode::run(row, decode::field("teams", decode::field("away", decode::field("id", decode::int))))
  let is_home_win = try decode::run(row, decode::field("teams", decode::field("home", decode::field("winner", decode::nullable(decode::bool)))))
  let is_away_win = try decode::run(row, decode::field("teams", decode::field("away", decode::field("winner", decode::nullable(decode::bool)))))
  let home_goals = try decode::run(row, decode::field("goals", decode::field("home", decode::nullable(decode::int))))
  let away_goals = try decode::run(row, decode::field("goals", decode::field("away", decode::nullable(decode::int))))

  let winner_id: Int? = match is_home_win.is_some() {
    true => maybe::some(home_team_id),
    false => {
      match is_away_win.is_some() {
        true => maybe::some(away_team_id),
        false => maybe::none()
      }
    }
  }

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    away_team_id: away_team_id,
    home_goals: home_goals.or(0),
    away_goals: away_goals.or(0),
    winner_id: maybe::none(),
  })
}

fn fetch_season(league_id: Int, season: Int) [Match] {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err {
    io::print("Error fetching fixtures: {err}")
    List::new<Match>()
  }

  let body = decode::any(res.body)
  try decode::run(body, decode::field("response", decode::list(decode_fixture_entry))) -> errs {
    io::print("Error decoding body.response: {errs.at(0)}")
    List::new<Match>()
  }
}

fn update_match(db: sqlite::Database, m: Match) {
  match db.update("matches", "id={m.id}", m) {
    ok => {},
    err => io::print("Error updating match {m.id}: {err}"),
  }
}

// MLS
let league_ids = [253]

// update the matches in the db
fn sync(db: sqlite::Database) {
  for id in league_ids {
    for m in fetch_season(id, 2025) {
      let exists = db.exists("matches", "id = {m.id}").expect("Error checking for match in db")
      if exists {
        match db.update("matches", "id={m.id}", m) {
          err => io::print("Error updating match({m.id}): {err}"),
          ok => {},
        }
      } else {
        match db.insert("matches", m) {
          err => io::print("Error inserting match({m.id}): {err}"),
          ok => {},
        }
      }
    }

    io::print("Updated match data for league {id}")
  }
}

fn get_league(db: sqlite::Database, league_id: Int) [Match]!Str {
  let rows = try db.query("select * from matches where league_id = {league_id} order by timestamp desc")
  let matches = try decode::run(rows, decode::list(decode_match)) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(matches)
}

private fn ints_to_str(ints: [Int]) Str {
  mut str = ""
  for int, idx in ints {
    if idx == 0 {
      str = int.to_str()
    } else {
      str = "{str},{int}"
    }
  }
  str
}

fn get(db: sqlite::Database, ids: [Int]) [Match]!Str {
  let rows = try db.query("select * from matches where id in ({ints_to_str(ids)});")
  let matches = try decode::run(rows, decode::list(decode_match)) -> errors {
    Result::err(errors.at(0).to_str())
  }
  Result::ok(matches)
}
