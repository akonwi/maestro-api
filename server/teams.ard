use ard/env
use ard/decode
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct Team {
  id: Int,
	name: Str,
	code: Str?,
}

fn decode_team(data: decode::Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let code = try decode::run(data, decode::field("code", decode::nullable(decode::string)))

  Result::ok(Team {
    id: id,
    name: name,
    code: code,
  })
}

fn get_all(db: sqlite::Database) [Team]!Str {
  let rows = try db.query("select * from teams")
  let teams = try decode::run(rows, decode::list(decode_team)) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(teams)
}

// return a map of id to name
fn get_in_matches(db: sqlite::Database, ids: [Int]) [Int:Str]!Str {
  mut ids_string = ""
  for id, i in ids {
    if i == 0 {
      ids_string = id.to_str()
    } else {
      ids_string = "{ids_string},{id}"
    }
  }
  let rows = try db.query("
    select t.id, t.name from teams t
    join matches m on m.home_team_id = t.id or m.away_team_id = t.id
    where m.id in ({ids_string});
  ")

  struct Row { id: Int, name: Str }
  let decode_row = fn(row: decode::Dynamic) Row![decode::Error] {
    let id = try decode::run(row, decode::field("id", decode::int))
    let name = try decode::run(row, decode::field("name", decode::string))
    Result::ok(Row{id:id, name:name})
  }

  let entries = try decode::run(rows, decode::list(decode_row)) -> errors {
    mut msg = ""
    for e in errors {
      msg = "{msg}, {e.to_str()}"
    }
    Result::err(msg)
  }

  mut id_to_name: [Int:Str] = [:]
  for entry in entries {
    id_to_name.set(entry.id, entry.name)
  }

  Result::ok(id_to_name)
}

struct Snapshot {
	id: Int,
	name: Str,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,

	cleansheets: Int,
	one_conceded: Int,
	two_plus_conceded: Int,
}

struct Comparison {
  home: Snapshot,
  away: Snapshot,
}

fn get_snapshot(db: sqlite::Database, id: Int) Snapshot!Str {
	let wins = try db.count("matches", "winner_id = {id}")
	let losses = try db.count("matches", "
	  (home_team_id = {id} OR away_team_id = {id})
		and status = 'FT'
		and winner_id is not null
		and winner_id != {id}"
	)
	let draws = try db.count("matches", "
	  (home_team_id = {id} OR away_team_id = {id})
		and status = 'FT'
		and winner_id is null"
	)
	let team_row = try db.first("select name from teams where id = {id}")
	let name = try decode::run(team_row, decode::field("name", decode::string)) -> errs {
	  Result::err("Unable to decode team name: {errs.at(0)}")
	}

	let home_goals_for_raw = try db.first(
	  "SELECT COALESCE(SUM(home_goals), 0) as value FROM matches
		where home_team_id = {id} and status = 'FT'"
	)
	let home_goals_for = try decode::run(home_goals_for_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode home goals for: {errs.at(0)}")
	}
	let away_goals_for_raw = try db.first(
	  "SELECT COALESCE(SUM(away_goals), 0) as value FROM matches
		where away_team_id = {id} and status = 'FT'"
	)
	let away_goals_for = try decode::run(away_goals_for_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode away goals for: {errs.at(0)}")
	}

	let home_goals_against_raw = try db.first(
	  "SELECT COALESCE(SUM(away_goals), 0) as value FROM matches
		where home_team_id = {id} and status = 'FT'"
	)
	let home_goals_against = try decode::run(home_goals_against_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode home goals against: {errs.at(0)}")
	}
	let away_goals_against_raw = try db.first(
	  "SELECT COALESCE(SUM(home_goals), 0) as value FROM matches
		where away_team_id = {id} and status = 'FT'"
	)
	let away_goals_against = try decode::run(away_goals_against_raw, decode::field("value", decode::int)) -> errs {
	  Result::err("Unable to decode away goals against: {errs.at(0)}")
	}

	let cleansheets = try db.count("matches",
	  "status = 'FT'
		and (
		  (home_team_id = {id} and away_goals = 0)
			OR (away_team_id = {id} and home_goals = 0)
		)"
	)
	let one_conceded = try db.count("matches",
	  "status = 'FT'
		and (
		  (home_team_id = {id} and away_goals = 1)
			OR (away_team_id = {id} and home_goals = 1)
		)"
	)
	let total_games = wins + losses + draws
	let two_plus_conceded = total_games - cleansheets - one_conceded

	Result::ok(Snapshot{
	  id: id,
		name: name,
	  wins: wins,
		losses: losses,
		draws: draws,
		goals_for: home_goals_for + away_goals_for,
		goals_against: home_goals_against + away_goals_against,
		cleansheets: cleansheets,
		one_conceded: one_conceded,
		two_plus_conceded: two_plus_conceded,
	})
}

fn get_comparison(db: sqlite::Database, home_id: Int, away_id: Int) Comparison!Str {
  let home = try get_snapshot(db, home_id)
  let away = try get_snapshot(db, away_id)
  Result::ok(Comparison{
    home: home,
    away: away,
  })
}

fn decode_from_api(data: decode::Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let code = try decode::run(data, decode::field("code", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    name: name,
    code: code,
  })
}

fn to_values(team: Team) [Str:decode::Dynamic] {
  mut values = [
    "id": decode::from_int(team.id),
    "name": decode::from_str(team.name),
  ]
  match team.code {
    code => values.set("code", decode::from_str(code)),
    _ => {},
  }
  values
}

fn decode_and_save(db: sqlite::Database, data: decode::Dynamic) Bool![decode::Error] {
  let teams = try decode::run(data,
    decode::field("response",
      decode::list(decode::field("team", decode_from_api))
    )
  )

  for t in teams {
    let exists = db.exists("teams", "id = {t.id}").expect("Error checking for team in db")
    if exists {
      match db.update("teams", "id={t.id}", to_values(t)) {
        ok => {},
        err => io::print("Error updating team {t.name}: {err}")
      }
    } else {
      match db.insert("teams", to_values(t)) {
        ok => {},
        err => io::print("Error inserting team {t.name}: {err}")
      }
    }
  }

  Result::ok(true)
}

// load teams into the db
fn sync(db: sqlite::Database) {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }

  for league_id in [39, 40, 253] {
    let req = http::Request{
      method: http::Method::Get,
      url: "https://v3.football.api-sports.io/teams?league={league_id}&season=2025",
      headers: [
        "x-rapidapi-key": api_key,
        "Accept": "application/json",
      ],
    }
    match http::send(req) {
      ok(resp) => {
        decode_and_save(db, decode::json(resp.body))
      },
      err => io::print("Error fetching teams in league {league_id}: {err}")
    }

    io::print("Synced teams in league {league_id}")
  }
}
