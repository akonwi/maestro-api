use ard/env
use ard/decode
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

struct Team {
  id: Int,
	name: Str,
	code: Str?,
}

fn decode_team(data: Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let code = try decode::run(data, decode::field("code", decode::nullable(decode::string)))

  Result::ok(Team {
    id: id,
    name: name,
    code: code,
  })
}

fn get_all(db: sqlite::Database) [Team]!Str {
  let rows = try db.query("select * from teams")
  let teams = try decode::run(rows, decode::list(decode_team)) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(teams)
}

// return a map of id to name
fn get_in_matches(db: sqlite::Database, ids: [Int]) [Int:Str]!Str {
  mut ids_string = ""
  for id, i in ids {
    if i == 0 {
      ids_string = id.to_str()
    } else {
      ids_string = "{ids_string},{id}"
    }
  }
  let rows = try db.query("
    select t.id, t.name from teams t
    join matches m on m.home_team_id = t.id or m.away_team_id = t.id
    where m.id in ({ids_string});
  ")

  struct Row { id: Int, name: Str }
  let decode_row = fn(row: Dynamic) Row![decode::Error] {
    let id = try decode::run(row, decode::field("id", decode::int))
    let name = try decode::run(row, decode::field("name", decode::string))
    Result::ok(Row{id:id, name:name})
  }

  let entries = try decode::run(rows, decode::list(decode_row)) -> errors {
    mut msg = ""
    for e in errors {
      msg = "{msg}, {e.to_str()}"
    }
    Result::err(msg)
  }

  mut id_to_name: [Int:Str] = [:]
  for entry in entries {
    id_to_name.set(entry.id, entry.name)
  }

  Result::ok(id_to_name)
}

struct Snapshot {
	id: Int,
	name: Str,
	num_games: Int,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,
	goals_diff: Int,
	xgf: Float,
	xga: Float,
	leakiness: Float,

	cleansheets: Int,
	one_conceded: Int,

	// could be presented as +1.5
	two_plus_conceded: Int,

	win_rate: Float,
}

fn decode_from_api(data: Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let code = try decode::run(data, decode::field("code", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    name: name,
    code: code,
  })
}

fn to_values(team: Team) [Str:Dynamic] {
  mut values = [
    "id": decode::from_int(team.id),
    "name": decode::from_str(team.name),
  ]
  match team.code {
    code => values.set("code", decode::from_str(code)),
    _ => {},
  }
  values
}

fn decode_and_save(db: sqlite::Database, data: Dynamic) Bool![decode::Error] {
  let teams = try decode::run(data,
    decode::field("response",
      decode::list(decode::field("team", decode_from_api))
    )
  )

  for t in teams {
    let exists = db.exists("teams", "id = {t.id}").expect("Error checking for team in db")
    if exists {
      match db.update("teams", "id={t.id}", to_values(t)) {
        ok => {},
        err => io::print("Error updating team {t.name}: {err}")
      }
    } else {
      match db.insert("teams", to_values(t)) {
        ok => {},
        err => io::print("Error inserting team {t.name}: {err}")
      }
    }
  }

  Result::ok(true)
}

// load teams into the db
fn sync(db: sqlite::Database) {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }

  for league_id in [39, 40, 253] {
    let req = http::Request{
      method: http::Method::Get,
      url: "https://v3.football.api-sports.io/teams?league={league_id}&season=2025",
      headers: [
        "x-rapidapi-key": api_key,
        "Accept": "application/json",
      ],
    }
    match http::send(req) {
      ok(resp) => {
        decode_and_save(db, decode::json(resp.body))
      },
      err => io::print("Error fetching teams in league {league_id}: {err}")
    }

    io::print("Synced teams in league {league_id}")
  }
}
