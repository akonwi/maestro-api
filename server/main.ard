use ard/async
use ard/env
use ard/io
use ard/http
use ard/json

use maestro/bets
use maestro/data
use maestro/db
use maestro/leagues
use maestro/matches
use maestro/teams

let res_headers = [
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE",
  "Access-Control-Allow-Headers": "Content-Type",
  "Content-Type": "application/json"
]

fn internal_error(msg: Str) http::Response {
  mut headers = res_headers
  headers.drop("Content-Type")
  http::Response{
    status: 500,
    body: msg,
    headers: headers,
  }
}

mut nf_headers = res_headers
nf_headers.drop("Content-Type")
let not_found = http::Response{status:404, body:"Not found", headers:nf_headers}

fn main() {
  let conn = db::init()

  // start fiber for updating db regularly
  async::start(fn() { data::sync() })

  let env_port = env::get("PORT").or("")
  if env_port.is_empty() {
    panic("Missing PORT environment variable")
  }

  let port = Int::from_str(env_port).or(3000)

  io::print("starting on port {port}")

  http::serve(
    port: port,
    handlers: [
      "/bets/overview": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let overview = try bets::get_overview(conn) -> internal_error
            mut match_ids: [Int] = []
            for b in overview.bets {
              match_ids.push(b.match_id)
            }
            let teams_by_id = try teams::get_in_matches(conn, match_ids) -> internal_error
            let matches = try matches::get(conn, match_ids) -> internal_error

            // local shape of response body
            struct Res {
              overview: bets::Overview,
              teams: [Int:Str],
              matches: [matches::Match]
            }
            match json::encode(Res{ overview:overview, teams:teams_by_id, matches:matches }) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/leagues": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let data = try leagues::get_all(conn) -> internal_error

            struct Res { leagues: [leagues::League] }
            match json::encode(Res{ leagues:data }) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/leagues/:id/matches": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let league_id = Int::from_str(req.path_param("id")).or(-1)
            let fixtures = try matches::get_league(conn, league_id) -> internal_error
            let teams = try teams::get_all(conn) -> internal_error

            struct Res { matches: [matches::Match], teams: [teams::Team] }
            match json::encode(Res{ matches:fixtures, teams:teams }) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/compare": fn(req: http::Request) http::Response {
        // accepts `home` and `away` ids in query params
        match req.method {
          http::Method::Get => {
            let home_id = Int::from_str(req.query_param("home")).or(-1)
            let away_id = Int::from_str(req.query_param("away")).or(-1)

            match home_id == -1 or away_id == -1 {
              true => {
                mut headers = res_headers
                headers.drop("Content-Type")
                http::Response{status: 400, body: "Invalid team id", headers: headers}
              },
              false => {
                let comparison = try teams::get_comparison(db: conn, home_id: home_id, away_id: away_id) -> internal_error
                match json::encode(comparison) {
                  ok(body) => http::Response{status:200, body:body, headers:res_headers},
                  err => internal_error(err)
                }
              }
            }
          },
          _ => not_found
        }
      },
    ],
  )
}
