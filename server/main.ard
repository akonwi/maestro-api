use ard/async
use ard/decode
use ard/io
use ard/http
use ard/json

use maestro/bets
use maestro/config
use maestro/db
use maestro/fixtures
use maestro/leagues
use maestro/matches
use maestro/predictions

let X_API_TOKEN = "X-Api-Token"

let res_headers = [
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, {X_API_TOKEN}",
  "Content-Type": "application/json"
]

fn internal_error(msg: Str) http::Response {
  mut headers = res_headers
  headers.drop("Content-Type")
  http::Response{
    status: 500,
    body: msg,
    headers: headers,
  }
}

fn unauthorized() http::Response {
  mut headers = res_headers
  headers.drop("Content-Type")
  http::Response{
    status: 403,
    headers: headers,
    body: "",
  }
}

fn empty_200() http::Response {
  http::Response{status: 200, headers: res_headers, body: ""}
}

mut nf_headers = res_headers
nf_headers.drop("Content-Type")
let not_found = http::Response{status:404, body:"Not found", headers:nf_headers}

fn main() {
  let conn = db::connect()
  db::migrate(conn)

  let secret = config::api_key()
  fn is_authorized(header: Str?) Bool {
    match header {
      h => secret == h,
      _ => false
    }
  }

  // start fiber for updating db regularly
  async::start(predictions::find_juice_worker)
  async::start(bets::update_outcomes)
  async::start(fn() { fixtures::sync(conn) })

  let port = config::port()
  io::print("starting on port {port}")

  http::serve(
    port: port,
    handlers: [
      "/juice": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let date = req.query_param("date")
            let body = try predictions::get_juice(conn, date) -> internal_error
            http::Response{status: 200, headers: res_headers, body: body}
          },
          _ => not_found
        }
      },

      "/bets": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let found_result = match Int::from_str(req.query_param("match_id")) {
              match_id => {
                let found = try bets::find_by_match(conn, match_id) -> internal_error
                struct Res { bets: [bets::Bet] }
                Res{bets: found}
              },
              _ => {
                let after = Int::from_str(req.query_param("after"))
                try bets::get_all_paged(conn, after) -> internal_error
              }
            }

            let body = try json::encode(found_result) -> internal_error
            http::Response{status: 200, headers: res_headers, body: body}
          },
          http::Method::Options => empty_200(),
          http::Method::Post => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              false => unauthorized(),
              true => {
                let raw_body = try decode::from_json(req.body.or("")) -> err { internal_error("Unable to parse request body: {err}") }
                let bet = try bets::create(conn, raw_body) -> internal_error
                let body = try json::encode(bet) -> internal_error
                http::Response{status: 200, headers: res_headers, body: body}
              },
            }
          },
          _ => not_found
        }
      },

      "/bets/:id": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Del => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              false => unauthorized(),
              true => {
                match Int::from_str(req.path_param("id")) {
                  id => {
                    try bets::delete(conn, id) -> internal_error
                    http::Response{status: 204, headers: res_headers, body: ""}
                  },
                  _ =>  not_found
                }
              }
            }
          },
          http::Method::Options => empty_200(),
          http::Method::Patch => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              false => unauthorized(),
              true => {
                match Int::from_str(req.path_param("id")) {
                  id => {
                    let raw_body = try decode::from_json(req.body.or("")) -> err { internal_error("Unable to parse request body: {err}") }
                    try bets::update(conn, id, raw_body) -> internal_error
                    empty_200()
                  },
                  _ => not_found
                }
              },
            }
          },
          _ => not_found
        }
      },

      "/bets/overview": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let overview = try bets::get_overview(conn) -> internal_error

            match json::encode(overview) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/leagues": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let data = try leagues::get_all(conn) -> internal_error

            struct Body { leagues: [leagues::League] }
            match json::encode(Body{ leagues: data }) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          http::Method::Post => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              true => {
                let body = try decode::from_json(req.body.or("")) -> internal_error
                // todo: not all failures are 500
                let input = try leagues::decode_follow_request(body) -> errs { internal_error(errs.at(0).to_str()) }
                try leagues::follow(conn, input) -> internal_error

                http::Response{status: 200, headers: res_headers, body: ""}
              },
              false => unauthorized()
            }
          },
           _ => not_found
        }
      },

      "/leagues/:id/hide": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Options => empty_200(),
          http::Method::Post => {
            match Int::from_str(req.path_param("id")) {
              id => conn.query("INSERT INTO ignored_league (id) VALUES (@id)").run(["id": id]),
              _ => ()
            }
            http::Response{status: 200, headers: res_headers, body: "true"}
          },
          _ => not_found
        }
      },

      "/leagues/:id/matches": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let league_id = try Int::from_str(req.path_param("id")) -> _ { not_found }
            let fixtures = try matches::get_season(league_id) -> internal_error

            struct Res { matches: [matches::Match] }
            match json::encode(Res{ matches: fixtures }) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/matches/:id": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let id = try Int::from_str(req.path_param("id")) -> _ { not_found }
            let fixture = try matches::get(id) -> internal_error

            match json::encode(fixture) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/analysis/:matchId": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let fixture_id = try Int::from_str(req.path_param("matchId")) -> _ { not_found }
            match fixture_id < -1 {
              true => {
                mut headers = res_headers
                headers.drop("Content-Type")
                http::Response{status: 400, body: "Invalid match id", headers: headers}
              },
              false => {
                let analysis = try predictions::get_comparison(fixture_id) -> err {
                  internal_error("Error getting analysis: {err}")
                }

                struct Res {
                  comparison: predictions::Comparison,
                }

                match json::encode(Res{ comparison: analysis }) {
                  ok(body) => http::Response{status:200, body:body, headers:res_headers},
                  err => internal_error(err)
                }
              }
            }
          },
          _ => not_found
        }
      },
    ],
  )
}
