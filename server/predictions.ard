use ard/env
use ard/decode
use ard/http
use ard/maybe
use ard/sqlite

use maestro/matches
use maestro/teams

// --- Predictions come from API-Football

struct Winner {
  id: Int,
  name: Str,
  comment: Str?,
}

struct Prediction {
  advice: Str?,
  winner: Winner?,
  win_or_draw: Bool?,
  home_goals: Str,
  away_goals: Str,
}

private fn decode_winner(data: decode::Dynamic) Winner![decode::Error] {
  let winner_id = try decode::run(data, decode::field("id", decode::int))
  let winner_name = try decode::run(data,  decode::field("name", decode::string))
  let winner_comment = try decode::run(data,  decode::field("comment", decode::nullable(decode::string)))

  Result::ok(Winner{
    id: winner_id,
    name: winner_name,
    comment: winner_comment,
  })
}

private fn decode_entry(data: decode::Dynamic) Prediction![decode::Error] {
  let advice = try decode::run(data, decode::field("advice", decode::nullable(decode::string)))
  let winner = try decode::run(data, decode::field("winner", decode::nullable(decode_winner)))
  let win_or_draw = try decode::run(data, decode::field("win_or_draw", decode::nullable(decode::bool)))
  let home_goals = try decode::run(data, decode::field("goals", decode::field("home", decode::nullable(decode::string))))
  let away_goals = try decode::run(data, decode::field("goals", decode::field("away", decode::nullable(decode::string))))


  Result::ok(Prediction{
    advice: advice,
    winner: winner,
    win_or_draw: win_or_draw,
    home_goals: home_goals.or("0"),
    away_goals: away_goals.or("0"),
  })
}

fn get(fixture_id: Int) Prediction!Str {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  })

  let body = decode::json(res.body)
  let predictions = try decode::run(body, decode::field("response", decode::list(decode::field("predictions", decode_entry)))) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(predictions.at(0))
}

// --- Analysis is based on my personal algorithm
struct BetRecommendations {
  home_goals: Float?,
  away_goals: Float?,
  total_goals: Float?,
  both_teams_to_score: Bool?,
}

struct ConfidenceScore {
  score: Float,
  xg_advantage: Float,
  quality_gap: Float,
  def_vuln: Float,
  label: Str,   // "High", "Medium", "Low"
}

struct Analysis {
  match_id: Int,
  recommendations: BetRecommendations,
  home_confidence: ConfidenceScore,
  away_confidence: ConfidenceScore,
}

// Get naive/conservative base line
private fn get_team_goal_line(xgf: Float, xga: Float) Float {
  let xg = (xgf + xga) / 2.0
  Float::floor(xg - 0.5) + 0.5
}

fn calculate_confidence(attacking: teams::Snapshot, defending: teams::Snapshot) ConfidenceScore {
  let xg_advantage = attacking.xgf - defending.xga
  let quality_gap = attacking.win_rate - defending.win_rate
  mut def_vuln = 0.0
  if defending.leakiness <= 30.0 {
    def_vuln = 0.1
  } else if defending.leakiness < 50.0 {
    def_vuln = 0.3
  }
  if defending.leakiness >= 50.0 {
    def_vuln = 0.5
  }

  let score = xg_advantage + quality_gap + def_vuln

  mut category = "Low"
  if score >= 0.75 {
    category = "High"
  } else if score >= 0.51 {
    category = "Medium"
  }

  ConfidenceScore{
    score: score,
    xg_advantage: xg_advantage,
    quality_gap: quality_gap,
    def_vuln: def_vuln,
    label: category
  }
}

fn get_analysis(db: sqlite::Database, fixture_id: Int) Analysis!Str {
  let fixture = try matches::get(db, fixture_id)
  let home = try teams::get_snapshot(db, fixture.home_team_id)
  let away = try teams::get_snapshot(db, fixture.away_team_id)

  mut recs = BetRecommendations{}

  recs.home_goals = get_team_goal_line(home.xgf, away.xga)
  recs.away_goals = get_team_goal_line(away.xgf, home.xga)

  Result::ok(Analysis{
    match_id: fixture_id,
    recommendations: recs,
    home_confidence: calculate_confidence(attacking: home, defending: away),
    away_confidence: calculate_confidence(attacking: away, defending: home),
  })
}
