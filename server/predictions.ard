use ard/env
use ard/decode
use ard/http
use ard/maybe
use ard/sqlite

use maestro/matches
use maestro/teams

struct Winner {
  id: Int,
  name: Str,
  comment: Str?,
}

struct Prediction {
  advice: Str?,
  winner: Winner?,
  win_or_draw: Bool?,
  home_goals: Str,
  away_goals: Str,
}

struct BetRecommendations {
  home_goals: Float?,
  away_goals: Float?,
  total_goals: Float?,
  both_teams_to_score: Bool?,
}

struct Analysis {
  match_id: Int,
  recommendations: BetRecommendations
}

private fn decode_winner(data: decode::Dynamic) Winner![decode::Error] {
  let winner_id = try decode::run(data, decode::field("id", decode::int))
  let winner_name = try decode::run(data,  decode::field("name", decode::string))
  let winner_comment = try decode::run(data,  decode::field("comment", decode::nullable(decode::string)))

  Result::ok(Winner{
    id: winner_id,
    name: winner_name,
    comment: winner_comment,
  })
}

private fn decode_entry(data: decode::Dynamic) Prediction![decode::Error] {
  let advice = try decode::run(data, decode::field("advice", decode::nullable(decode::string)))
  let winner = try decode::run(data, decode::field("winner", decode::nullable(decode_winner)))
  let win_or_draw = try decode::run(data, decode::field("win_or_draw", decode::nullable(decode::bool)))
  let home_goals = try decode::run(data, decode::field("goals", decode::field("home", decode::nullable(decode::string))))
  let away_goals = try decode::run(data, decode::field("goals", decode::field("away", decode::nullable(decode::string))))


  Result::ok(Prediction{
    advice: advice,
    winner: winner,
    win_or_draw: win_or_draw,
    home_goals: home_goals.or("0"),
    away_goals: away_goals.or("0"),
  })
}

fn get(fixture_id: Int) Prediction!Str {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  })

  let body = decode::json(res.body)
  let predictions = try decode::run(body, decode::field("response", decode::list(decode::field("predictions", decode_entry)))) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(predictions.at(0))
}

// (AxGF + BxGA) / 2
private fn get_team_goal_line(xgf: Float, xga: Float) Float {
  let xg = (xgf + xga) / 2.0
  match xg >= 2.0 {
    true => 2.5,
    false => match xg >= 1.5 {
      true => 1.5,
      false => 0.5
    }
  }
}

struct ConfidenceScore {
  score: Float,        // 0-100 overall confidence
  breakdown: Str,      // Detailed scoring breakdown
  category: Str,       // "High", "Medium", "Low"
}

fn calculate_confidence(attacking_team: teams::Snapshot, defending_team: teams::Snapshot) ConfidenceScore {
  mut total_score = 0.0
  mut breakdown = ""

  // 1. Expected Goals Advantage (60% weight = 60 points max)
  let xg_advantage = attacking_team.xgf - defending_team.xga
  mut xg_score = 0.0
  if xg_advantage >= 0.5 {
    xg_score = 60.0
  } else if xg_advantage >= 0.3 {
    xg_score = 45.0
  } else if xg_advantage >= 0.1 {
    xg_score = 30.0
  } else if xg_advantage >= 0.0 {
    xg_score = 15.0
  }
  total_score =+ xg_score
  breakdown = "xG advantage: {xg_advantage} ({xg_score} pts)"

  // 2. Team Quality Gap (30% weight = 30 points max)
  let quality_gap = attacking_team.win_rate - defending_team.win_rate
  mut quality_score = 0.0
  if quality_gap >= 30.0 {
    quality_score = 30.0
  } else if quality_gap >= 20.0 {
    quality_score = 22.0
  } else if quality_gap >= 10.0 {
    quality_score = 15.0
  } else if quality_gap >= 0.0 {
    quality_score = 8.0
  }
  total_score =+ quality_score
  breakdown = "{breakdown}, Quality gap: {quality_gap}% ({quality_score} pts)"

  // 3. Defensive Vulnerability (10% weight = 10 points max)
  mut def_score = 1.0
  if defending_team.leakiness >= 60.0 {
    def_score = 10.0
  } else if defending_team.leakiness >= 45.0 {
    def_score = 7.0
  } else if defending_team.leakiness >= 30.0 {
    def_score = 4.0
  }
  total_score =+ def_score
  breakdown = "{breakdown}, Def vulnerability: {defending_team.leakiness}% ({def_score} pts)"

  mut category = "Low"
  if total_score >= 80.0 {
    category = "High"
  } else if total_score >= 60.0 {
    category = "Medium"
  }

  ConfidenceScore{
    score: total_score,
    breakdown: breakdown,
    category: category
  }
}

fn get_analysis(db: sqlite::Database, fixture_id: Int) Analysis!Str {
  let fixture = try matches::get(db, fixture_id)
  let home = try teams::get_snapshot(db, fixture.home_team_id)
  let away = try teams::get_snapshot(db, fixture.away_team_id)

  mut recs = BetRecommendations{}

  let home_confidence = calculate_confidence(home, away)
  if home_confidence.score >= 60.0 {  // Medium+ confidence threshold
    let expected_goals = (home.xgf + away.xga) / 2.0
    recs.home_goals = calculate_line(expected_goals)
  }
  recs.home_goals = get_team_goal_line(home.xgf, away.xga)
  recs.away_goals = get_team_goal_line(away.xgf, home.xga)

  Result::ok(Analysis{
    match_id: fixture_id,
    recommendations: recs
  })
}
