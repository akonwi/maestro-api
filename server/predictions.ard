use ard/dates
use ard/decode
use ard/env
use ard/fs
use ard/http
use ard/io
use ard/json
use ard/maybe
use ard/sqlite

use maestro/config
use maestro/matches
use maestro/odds
use maestro/teams

// --- Predictions come from API-Football

struct Winner {
  id: Int,
  name: Str,
  comment: Str?,
}

struct Prediction {
  // predictions
  advice: Str?,
  winner: Winner?,
  win_or_draw: Bool?,
  home_goals: Str,
  away_goals: Str,
}

private fn decode_winner(data: Dynamic) Winner![decode::Error] {
  let winner_id = try decode::run(data, decode::field("id", decode::int))
  let winner_name = try decode::run(data,  decode::field("name", decode::string))
  let winner_comment = try decode::run(data,  decode::field("comment", decode::nullable(decode::string)))

  Result::ok(Winner{
    id: winner_id,
    name: winner_name,
    comment: winner_comment,
  })
}

private fn decode_entry(data: Dynamic) Prediction![decode::Error] {
  let advice = try decode::run(data, decode::field("advice", decode::nullable(decode::string)))
  let winner = try decode::run(data, decode::field("winner", decode::nullable(decode_winner)))
  let win_or_draw = try decode::run(data, decode::field("win_or_draw", decode::nullable(decode::bool)))
  let home_goals = try decode::run(data, decode::field("goals", decode::field("home", decode::nullable(decode::string))))
  let away_goals = try decode::run(data, decode::field("goals", decode::field("away", decode::nullable(decode::string))))


  Result::ok(Prediction{
    advice: advice,
    winner: winner,
    win_or_draw: win_or_draw,
    home_goals: home_goals.or("0"),
    away_goals: away_goals.or("0"),
  })
}

fn get(fixture_id: Int) Prediction!Str {
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  })

  let body = decode::json(res.body)
  let predictions = try decode::run(body, decode::field("response", decode::list(decode::field("predictions", decode_entry)))) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(predictions.at(0))
}

// --- Analysis is based on my personal algorithm
struct BetRecommendations {
  home_goals: Float?,
  away_goals: Float?,
  total_goals: Float?,
  both_teams_to_score: Bool?,
}

struct ConfidenceScore {
  score: Float,
  xg_advantage: Float,
  quality_gap: Float,
  def_vuln: Float,
  label: Str,   // "High", "Medium", "Low"
}

struct Analysis {
  match_id: Int,
  recommendations: BetRecommendations,
  home_confidence: ConfidenceScore,
  away_confidence: ConfidenceScore,
}

// Get naive/conservative base line
private fn get_team_goal_line(xgf: Float, xga: Float) Float {
  let xg = (xgf + xga) / 2.0
  Float::floor(xg - 0.5) + 0.5
}

fn calculate_confidence(attacking: teams::Snapshot, defending: teams::Snapshot) ConfidenceScore {
  let xg_advantage = attacking.xgf - defending.xga
  let quality_gap = attacking.win_rate - defending.win_rate
  mut def_vuln = 0.0
  if defending.leakiness <= 30.0 {
    def_vuln = 0.1
  } else if defending.leakiness < 50.0 {
    def_vuln = 0.3
  }
  if defending.leakiness >= 50.0 {
    def_vuln = 0.5
  }

  let score = xg_advantage + quality_gap + def_vuln

  mut category = "Low"
  if score >= 0.75 {
    category = "High"
  } else if score >= 0.51 {
    category = "Medium"
  }

  ConfidenceScore{
    score: score,
    xg_advantage: xg_advantage,
    quality_gap: quality_gap,
    def_vuln: def_vuln,
    label: category
  }
}

fn get_analysis(db: sqlite::Database, fixture_id: Int) Analysis!Str {
  let fixture = try matches::get(db, fixture_id)
  let home = try teams::get_snapshot(db, fixture.home_team_id)
  let away = try teams::get_snapshot(db, fixture.away_team_id)

  mut recs = BetRecommendations{}

  recs.home_goals = get_team_goal_line(home.xgf, away.xga)
  recs.away_goals = get_team_goal_line(away.xgf, home.xga)

  Result::ok(Analysis{
    match_id: fixture_id,
    recommendations: recs,
    home_confidence: calculate_confidence(attacking: home, defending: away),
    away_confidence: calculate_confidence(attacking: away, defending: home),
  })
}

// 2. calc over/under averages
// 3. filter out bets aligned with calculations and over -150 odds


struct Stats {
  games: Int,
  avg_gf: Float,
  avg_ga: Float,
}

struct TeamStats {
  home: Stats,
  away: Stats,
}

fn decode_stats(data: Dynamic) Stats![decode::Error] {
  let num_games = try decode::run(data,
    decode::field(
      "league",
      decode::field("fixtures",
        decode::field("played", decode::field("total", decode::int))
      )
    )
  )

  let gf = try decode::run(data,
    decode::field(
      "league",
      decode::field("goals",
        decode::field("for", decode::field("average", decode::field("total", decode::string)))
      )
    )
  )
  let ga = try decode::run(data,
    decode::field(
      "league",
      decode::field("goals",
        decode::field("against", decode::field("average", decode::field("total", decode::string)))
      )
    )
  )

  Result::ok(Stats{
    games: num_games,
    avg_gf: Float::from_str(gf).or(0.0),
    avg_ga: Float::from_str(ga).or(0.0),
  })
}

fn decode_team_stats(data: Dynamic) TeamStats![decode::Error] {
  let home = try decode::run(data, decode::field("teams", decode::field("home", decode_stats)))
  let away = try decode::run(data, decode::field("teams", decode::field("away", decode_stats)))

  Result::ok(TeamStats{
    home: home,
    away: away,
  })
}

fn get_stats(fixture_id: Int) TeamStats!Str {
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  })

  let body = decode::json(res.body)
  let stats = try decode::run(
    body,
    decode::field("response", decode::list(decode_team_stats))
  ) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(stats.at(0))
}

struct FixturePicks {
  fixture: matches::Fixture,
  stats: [odds::Stat]
}

fn pick_team_goal_lines(odd: odds::Stat, stats: Stats, mut entry: FixturePicks) {
  mut lines: [odds::Line] = []
  for line in odd.values {
    if line.name == "Over 1.5" and stats.avg_gf > 1.5 {
      lines.push(line)
    }
    if line.name == "Over 2.5" and stats.avg_gf > 2.0 {
      lines.push(line)
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::Stat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn pick_cleansheet_lines(odd: odds::Stat, stats: Stats, mut entry: FixturePicks) {
  mut lines: [odds::Line] = []
  for line in odd.values {
    if line.name == "No" and stats.avg_ga > 1.5 {
      lines.push(line)
    }

    // be extremely conservative
    if line.name == "Yes" and stats.avg_ga < 1.0 {
      lines.push(line)
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::Stat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn find_good_odds(db: sqlite::Database) {
  mut entries: [FixturePicks] = []
  for fixture in matches::find_today() {
    match get_stats(fixture.id) {
      ok(stats) => {
        if stats.home.games > 7 {
          mut entry = FixturePicks{
            fixture: fixture,
            stats: [],
          }

          // find odds, if team over/under makes sense, save it
          let bets = match odds::get(fixture.id) {
            ok(all_odds) => {
              for odd in all_odds {
                // total goals - home
                if odd.id == 16 {
                  pick_team_goal_lines(odd, stats.home, entry)
                }

                // total goals - away
                if odd.id == 17 {
                  pick_team_goal_lines(odd, stats.away, entry)
                }

                // cleansheet - home
                if odd.id == 27 {
                  pick_cleansheet_lines(odd, stats.home, entry)
                }

                // cleansheet - away
                if odd.id == 28 {
                  pick_cleansheet_lines(odd, stats.away, entry)
                }
              }
            },
            err => io::print("Error getting odds for fixture {fixture.id}: {err}")
          }

          if entry.stats.size() > 0 {
            entries.push(entry)
          }
        }
      },
      err => io::print("Error getting prediction for fixture {fixture.id}: {err}")
    }
  }

  io::print("Found {entries.size()} good bets")

  match json::encode(entries) {
    ok(content) => {
      let today = dates::get_today()
      io::print("Saving juice: {today}")
      match db.upsert("juice", "id = '{today}'", ["id": decode::from_str(today), "raw_data": decode::from_str(content)]) {
        ok => {},
        err => io::print("Error saving juice: {err}")
      }
    },
    err => io::print("Error encoding juice data to JSON: {err}")
  }
}

fn get_juice(db: sqlite::Database) Str!Str {
  let row = try db.first("select * from juice where id = '{dates::get_today()}';")
  let raw = try decode::run(row, decode::field("raw_data", decode::string)) -> errs {
    Result::err(errs.at(0).to_str())
  }

  Result::ok(raw)
}
