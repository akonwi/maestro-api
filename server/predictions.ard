use ard/dates
use ard/decode
use ard/env
use ard/fs
use ard/http
use ard/io
use ard/json
use ard/sqlite

use maestro/config
use maestro/matches
use maestro/odds
use maestro/teams

let HOME_TOTAL_GOALS = 16
let HOME_CLEANSHEET = 27
let AWAY_TOTAL_GOALS = 17
let AWAY_CLEANSHEET = 28

let decode_id = decode::field("id", decode::int)
let decode_name = decode::field("name", decode::string)

// Get naive/conservative base line
private fn get_team_goal_line(xgf: Float, xga: Float) Float {
  let xg = (xgf + xga) / 2.0
  Float::floor(xg - 0.5) + 0.5
}

struct Snapshot {
	id: Int,
	name: Str,
	num_games: Int,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,
	one_plus_scored: Int, // number of games in which team scored > 1 goal
	strike_rate: Float, // percentage of matches finding the net
	goals_diff: Int,
	xgf: Float,
	xga: Float,
	leakiness: Float,

	cleansheets: Int,
	one_conceded: Int,

	// could be presented as +1.5
	two_plus_conceded: Int,

	win_rate: Float,
}

struct Comparison {
  home: Snapshot,
  away: Snapshot,
}

fn get_comparison(fixture_id: Int) Comparison!Str {
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  })

  fn decode_stats(data: Dynamic) Snapshot![decode::Error] {
    let id = try decode_id(data)
    let name = try decode_name(data)
    let league_data = try decode::extract_field(data, "league") -> found {
      Result::err([decode::Error{
        expected: "Field",
        found: found,
        path: ["league"]
      }])
    }
    let num_played = try decode::run(league_data, decode::path(["fixtures", "played", "total"], decode::int))
    let wins = try decode::run(league_data, decode::path(["fixtures", "wins", "total"], decode::int))
    let losses = try decode::run(league_data, decode::path(["fixtures", "loses", "total"], decode::int))
    let draws = try decode::run(league_data, decode::path(["fixtures", "draws", "total"], decode::int))
    let goals_against = try decode::run(league_data, decode::path(["goals", "against", "total", "total"], decode::int))
    let xga = Float::from_int(goals_against) / Float::from_int(num_played)
    let goals_for = try decode::run(league_data, decode::path(["goals", "for", "total", "total"], decode::int))
    let xgf = Float::from_int(goals_for) / Float::from_int(num_played)
    let one_plus_scored = try decode::run(league_data, decode::path(["goals", "for", "under_over", "1.5", "over"], decode::int))
    let no_score = try decode::run(league_data, decode::path(["failed_to_score", "total"], decode::int))
    let cleansheets = try decode::run(league_data, decode::path(["clean_sheet", "total"], decode::int))
    let at_least_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "0.5", "over"], decode::int))
    let over_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "1.5", "over"], decode::int))
    let one_conceded = at_least_1_against - over_1_against
    let two_plus_conceded = over_1_against

    Result::ok(Snapshot{
      id: id,
      name: name,
      num_games: num_played,
      wins: wins,
      losses: losses,
      draws: draws,
      goals_against: goals_against,
      xga: xga,
      goals_for: goals_for,
      one_plus_scored: one_plus_scored,
      strike_rate: 1.0 - Float::from_int(no_score) / Float::from_int(num_played),
      xgf: xgf,
      goals_diff: goals_for - goals_against,
      cleansheets: cleansheets,
      one_conceded: one_conceded,
      two_plus_conceded: two_plus_conceded,
      leakiness: Float::from_int(two_plus_conceded) / Float::from_int(num_played) * 100.0,
      win_rate: Float::from_int(wins) / Float::from_int(num_played),
    })
  }

  fn decode_comparison(data: Dynamic) Comparison![decode::Error] {
    let home = try decode::run(data, decode::field("home", decode_stats))
    let away = try decode::run(data, decode::field("away", decode_stats))

    Result::ok(Comparison{
      home: home,
      away: away,
    })
  }

  let body = try decode::from_json(res.body)
  let comparison = try decode::run(body, decode::field("response", decode::at(0, decode::field("teams", decode_comparison)))) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(comparison)
}

// 2. calc over/under averages
// 3. filter out bets aligned with calculations and over -150 odds

struct Stats {
  games: Int,
  avg_gf: Float,
  avg_ga: Float,
}

struct TeamStats {
  home: Stats,
  away: Stats,
}

fn decode_stats(data: Dynamic) Stats![decode::Error] {
  let num_games = try decode::run(data,
    decode::field(
      "league",
      decode::field("fixtures",
        decode::field("played", decode::field("total", decode::int))
      )
    )
  )

  let gf = try decode::run(data,
    decode::field(
      "league",
      decode::field("goals",
        decode::field("for", decode::field("average", decode::field("total", decode::string)))
      )
    )
  )
  let ga = try decode::run(data,
    decode::field(
      "league",
      decode::field("goals",
        decode::field("against", decode::field("average", decode::field("total", decode::string)))
      )
    )
  )

  Result::ok(Stats{
    games: num_games,
    avg_gf: Float::from_str(gf).or(0.0),
    avg_ga: Float::from_str(ga).or(0.0),
  })
}

fn decode_team_stats(data: Dynamic) TeamStats![decode::Error] {
  let home = try decode::run(data, decode::field("teams", decode::field("home", decode_stats)))
  let away = try decode::run(data, decode::field("teams", decode::field("away", decode_stats)))

  Result::ok(TeamStats{
    home: home,
    away: away,
  })
}

fn get_stats(fixture_id: Int) TeamStats!Str {
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  })

  let body = decode::json(res.body)
  let stats = try decode::run(
    body,
    decode::field("response", decode::list(decode_team_stats))
  ) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(stats.at(0))
}

struct FixturePicks {
  fixture: matches::Fixture,
  stats: [odds::Stat]
}

fn pick_team_goal_lines(odd: odds::Stat, stats: Stats, mut entry: FixturePicks) {
  mut lines: [odds::Line] = []
  for line in odd.values {
    if line.name == "Over 1.5" and stats.avg_gf > 1.5 {
      lines.push(line)
    }
    if line.name == "Over 2.5" and stats.avg_gf > 2.0 {
      lines.push(line)
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::Stat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn pick_cleansheet_lines(odd: odds::Stat, stats: Stats, mut entry: FixturePicks) {
  mut lines: [odds::Line] = []
  for line in odd.values {
    if line.name == "No" and stats.avg_ga > 1.5 {
      lines.push(line)
    }

    // be extremely conservative
    if line.name == "Yes" and stats.avg_ga < 1.0 {
      lines.push(line)
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::Stat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn find_good_odds(db: sqlite::Database) {
  mut entries: [FixturePicks] = []
  for fixture in matches::find_today() {
    match get_stats(fixture.id) {
      ok(stats) => {
        if stats.home.games > 7 {
          mut entry = FixturePicks{
            fixture: fixture,
            stats: [],
          }

          // find odds, if team over/under makes sense, save it
          let bets = match odds::get(fixture.id) {
            ok(all_odds) => {
              for odd in all_odds {
                if odd.id == HOME_TOTAL_GOALS  {
                  pick_team_goal_lines(odd, stats.home, entry)
                }

                if odd.id == AWAY_TOTAL_GOALS {
                  pick_team_goal_lines(odd, stats.away, entry)
                }

                if odd.id == HOME_CLEANSHEET {
                  pick_cleansheet_lines(odd, stats.home, entry)
                }

                // cleansheet - away
                if odd.id == AWAY_CLEANSHEET {
                  pick_cleansheet_lines(odd, stats.away, entry)
                }
              }
            },
            err => io::print("Error getting odds for fixture {fixture.id}: {err}")
          }

          if entry.stats.size() > 0 {
            entries.push(entry)
          }
        }
      },
      err => io::print("Error getting prediction for fixture {fixture.id}: {err}")
    }
  }

  io::print("Found {entries.size()} good bets")

  match json::encode(entries) {
    ok(content) => {
      let today = dates::get_today()
      io::print("Saving juice: {today}")
      match db.upsert("juice", "id = '{today}'", ["id": decode::from_str(today), "raw_data": decode::from_str(content)]) {
        ok => {},
        err => io::print("Error saving juice: {err}")
      }
    },
    err => io::print("Error encoding juice data to JSON: {err}")
  }
}

fn get_juice(db: sqlite::Database, date: Str) Str!Str {
  let id = match date.is_empty() {
    true => dates::get_today(),
    false => date
  }

  let row = try db.first("select * from juice where id = '{id}';")
  match decode::is_void(row) {
    true => Result::ok("[]"),
    false => {
      let raw = try decode::run(row, decode::field("raw_data", decode::string)) -> errs {
        Result::err(errs.at(0).to_str())
      }

      Result::ok(raw)
    },
  }
}
