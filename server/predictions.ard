use ard/async
use ard/dates
use ard/decode
use ard/duration
use ard/env
use ard/fs
use ard/http
use ard/io
use ard/json
use ard/sql

use maestro/config
use maestro/db as _db
use maestro/leagues
use maestro/matches
use maestro/odds

let decode_id = decode::field("id", decode::int)
let decode_name = decode::field("name", decode::string)

fn get_standing(team_id: Int, league_id: Int, season: Int) Int {
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/standings?team={team_id}&league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }) -> _ { -1 }
  let body = try decode::from_json(res.body) -> _ { -1 }

  try decode::run(body, decode::field("response", decode::at(0, decode::path(["league", "standings"], decode::at(0, decode::at(0, decode::field("rank", decode::int))))))) -> _ { -1 }
}

struct Snapshot {
	id: Int,
	name: Str,
	num_games: Int,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,
	one_plus_scored: Int, // number of games in which team scored > 1 goal
	strike_rate: Float, // percentage of matches finding the net
	goals_diff: Int,
	xgf: Float,
	xga: Float,
	leakiness: Float,

	cleansheets: Int,
	one_conceded: Int,

	// could be presented as +1.5
	two_plus_conceded: Int,

	win_rate: Float,
	position: Int,
}

struct Comparison {
  home: Snapshot,
  away: Snapshot,
}

fn get_comparison(fixture_id: Int) Comparison!Str {
  let res = try http::send(http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/predictions?fixture={fixture_id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  })

  fn decode_stats(data: Dynamic) Snapshot![decode::Error] {
    let id = try decode_id(data)
    let name = try decode_name(data)
    let league_data = try decode::extract_field(data, "league") -> found {
      Result::err([decode::Error{
        expected: "Field",
        found: found,
        path: ["league"]
      }])
    }
    let num_played = try decode::run(league_data, decode::path(["fixtures", "played", "total"], decode::int))
    let wins = try decode::run(league_data, decode::path(["fixtures", "wins", "total"], decode::int))
    let losses = try decode::run(league_data, decode::path(["fixtures", "loses", "total"], decode::int))
    let draws = try decode::run(league_data, decode::path(["fixtures", "draws", "total"], decode::int))
    let goals_against = try decode::run(league_data, decode::path(["goals", "against", "total", "total"], decode::int))
    let xga = Float::from_int(goals_against) / Float::from_int(num_played)
    let goals_for = try decode::run(league_data, decode::path(["goals", "for", "total", "total"], decode::int))
    let xgf = Float::from_int(goals_for) / Float::from_int(num_played)
    let one_plus_scored = try decode::run(league_data, decode::path(["goals", "for", "under_over", "1.5", "over"], decode::int))
    let no_score = try decode::run(league_data, decode::path(["failed_to_score", "total"], decode::int))
    let cleansheets = try decode::run(league_data, decode::path(["clean_sheet", "total"], decode::int))
    let at_least_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "0.5", "over"], decode::int))
    let over_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "1.5", "over"], decode::int))
    let one_conceded = at_least_1_against - over_1_against
    let two_plus_conceded = over_1_against

    Result::ok(Snapshot{
      id: id,
      name: name,
      num_games: num_played,
      wins: wins,
      losses: losses,
      draws: draws,
      goals_against: goals_against,
      xga: xga,
      goals_for: goals_for,
      one_plus_scored: one_plus_scored,
      strike_rate: 1.0 - Float::from_int(no_score) / Float::from_int(num_played),
      xgf: xgf,
      goals_diff: goals_for - goals_against,
      cleansheets: cleansheets,
      one_conceded: one_conceded,
      two_plus_conceded: two_plus_conceded,
      leakiness: Float::from_int(two_plus_conceded) / Float::from_int(num_played) * 100.0,
      win_rate: Float::from_int(wins) / Float::from_int(num_played),
      position: -1,
    })
  }

  fn decode_comparison(data: Dynamic) Comparison![decode::Error] {
    let home = try decode::run(data, decode::field("home", decode_stats))
    let away = try decode::run(data, decode::field("away", decode_stats))

    Result::ok(Comparison{
      home: home,
      away: away,
    })
  }

  let body = try decode::from_json(res.body)
  mut comparison = try decode::run(body, decode::field("response", decode::at(0, decode::field("teams", decode_comparison)))) -> errs {
    Result::err(errs.at(0).to_str())
  }

  fn dynamic(data: Dynamic) Dynamic![decode::Error] {
    Result::ok(data)
  }

  match decode::run(body, decode::field("response", decode::at(0, decode::field("league", dynamic)))) {
    ok(raw_league) => {
      let league_id = try decode::run(raw_league, decode::field("id", decode::int)) -> _ { Result::ok(comparison) }
      let season = try decode::run(raw_league, decode::field("season", decode::int)) -> _ { Result::ok(comparison) }
      let home_pos = get_standing(league_id: league_id, season: season, team_id: comparison.home.id)
      let away_pos = get_standing(league_id: league_id, season: season, team_id: comparison.away.id)

      comparison.home.position = home_pos
      comparison.away.position = away_pos
    },
    err => {}
  }

  Result::ok(comparison)
}

struct FixturePicks {
  fixture: matches::Match,
  stats: [odds::Stat]
}

fn pick_outcome(odd: odds::Stat, comp: Comparison, mut entry: FixturePicks) {
  for pick in odd.values {
    if pick.odd >= -150 {
      if pick.name == "Home" and comp.home.goals_diff > 0 and comp.away.goals_diff < 0 {
        entry.stats.push(odds::Stat{
          id: odd.id,
          name: pick.name,
          values: [pick],
        })
      }
      if pick.name == "Away" and comp.away.goals_diff > 0 and comp.home.goals_diff < 0 {
        entry.stats.push(odds::Stat{
          id: odd.id,
          name: pick.name,
          values: [pick],
        })
      }
    }
  }
}

fn pick_team_goal_lines(odd: odds::Stat, stats: Snapshot, mut entry: FixturePicks) {
  mut lines: [odds::Line] = []
  for line in odd.values {
    if line.odd >= -150 {
      if line.name == "Over 1.5" and stats.xgf > 1.5 {
        lines.push(line)
      }
      if line.name == "Over 2.5" and stats.xgf >= 2.25 {
        lines.push(line)
      }
      if line.name == "Under 0.5" and stats.xgf <= 1.0 {
        lines.push(line)
      }
      if line.name == "Under 1.5" and stats.xgf <= 1.5 {
        lines.push(line)
      }
      if line.name == "Under 2.5" and stats.xgf < 2.5 {
        lines.push(line)
      }
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::Stat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn pick_cleansheet_lines(odd: odds::Stat, stats: Snapshot, mut entry: FixturePicks) {
  mut lines: [odds::Line] = []
  for line in odd.values {
    if line.odd >= -150 {
      if line.name == "No" and (stats.xga >= 1.5 or stats.leakiness >= 0.5) {
        lines.push(line)
      }

      // be extremely conservative
      if line.name == "Yes" and stats.xga < 1.0 {
        lines.push(line)
      }
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::Stat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

private fn save_juice(db: sql::Database, id: Str, raw: Str) Void!Str {
  io::print("Saving juice: {id}")
  let rows = try db.query("SELECT id FROM juice WHERE id = @id").first(["id": id])
  let sql = match rows.is_some() {
    true => "UPDATE juice SET raw_data = @raw WHERE id = @id",
    false => "INSERT INTO juice (id, raw_data) VALUES (@id, @raw)"
  }
  try db.query(sql).run(["id": id, "raw": raw]) -> err {
    let msg = "Error saving juice: {err}"
    io::print(msg)
    Result::err(msg)
  }
  Result::ok(())
}

private fn find_juice() {
  let db = _db::connect()
  let ignored_leagues = leagues::get_ignored(db)

  mut entries: [FixturePicks] = []
  for fixture in matches::find_today() {
    if not ignored_leagues.has(fixture.league.id) {
      match get_comparison(fixture.id) {
        ok(comp) => {
          if comp.home.num_games > 7 {
            mut entry = FixturePicks{
              fixture: fixture,
              stats: [],
            }
            // find odds, if team over/under makes sense, save it
            match odds::get(fixture.id) {
              ok(all_odds) => {
                for odd in all_odds {
                  if odd.id == odds::OUTCOME  {
                    pick_outcome(odd, comp, entry)
                  }

                  if odd.id == odds::HOME_TOTAL_GOALS  {
                    pick_team_goal_lines(odd, comp.home, entry)
                  }

                  if odd.id == odds::AWAY_TOTAL_GOALS {
                    pick_team_goal_lines(odd, comp.away, entry)
                  }

                  if odd.id == odds::HOME_CLEANSHEET {
                    pick_cleansheet_lines(odd, comp.home, entry)
                  }

                  if odd.id == odds::AWAY_CLEANSHEET {
                    pick_cleansheet_lines(odd, comp.away, entry)
                  }
                }
              },
              err => io::print("Error getting odds for fixture {fixture.id}: {err}")
            }

            if entry.stats.size() > 0 {
              entries.push(entry)
            }
          }
        },
        err => io::print("Error getting matchup data for fixture {fixture.id}: {err}")
      }
    }
  }

  io::print("Found {entries.size()} good bets")

  match json::encode(entries) {
    ok(content) => {
      save_juice(db, dates::get_today(), content)
    },
    err => io::print("Error encoding juice data to JSON: {err}")
  }

  db.close()
}

fn find_juice_worker() {
  while {
    find_juice()
    async::sleep(duration::from_hours(2))
  }
}

fn get_juice(db: sql::Database, date: Str) Str!Str {
  let id = match date.is_empty() {
    true => dates::get_today(),
    false => date
  }

  let row = try db.query("select * from juice where id = @id").first(["id": id])
  match row {
    row => {
      let raw = try decode::run(row, decode::field("raw_data", decode::string)) -> errs {
        Result::err(errs.at(0).to_str())
      }

      Result::ok(raw)
    },
    _ => Result::ok("[]"),
  }
}
