use ard/decode
use ard/http
use ard/io
use ard/sql

use maestro/config
use maestro/leagues

// todo: put this in ard/decode
fn dynamic(data: Dynamic) Dynamic![decode::Error] {
  Result::ok(data)
}

enum Status {
  not_started,
  finished
}

impl Str::ToString for Status {
  fn to_str() Str {
    match @ {
      Status::not_started => "not_started",
      Status::finished => "finished",
    }
  }
}

struct Fixture {
  id: Int,
  league_id: Int,
  timestamp: Int,
  status: Status,
  home_id: Int,
  away_id: Int,
  home_goals: Int,
  away_goals: Int,
}

let finished_statuses = ["FT", "AET", "PEN", "WO", "AWD"]

fn decode_short_status(data: Dynamic) Status![decode::Error] {
  let api_status = try decode::string(data)

  mut status = Status::not_started
  for s in finished_statuses {
    if s == api_status {
      status = Status::finished
      break
    }
  }

  Result::ok(status)
}

fn collapse_errors(prefix: Str, errors: [decode::Error]) Str {
  mut msg = prefix
  for e in errors {
    msg = "{msg}: {e}"
  }
  msg
}

fn print_errors(errors: [decode::Error]) {
  io::print(collapse_errors("", errors))
}

fn fetch(id: Int) Dynamic!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?id={id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err { Result::err("Error fetching fixture (id={id}): {err}") }
  let body = try decode::from_json(res.body) -> found { Result::err("Unable to parse response body as JSON (league={id}). Found {found}") }
  let entry = try decode::run(body, decode::field("response", decode::at(0, dynamic))) -> errs { Result::err(collapse_errors("", errs)) }
  Result::ok(entry)
}

struct TeamStats {
  id: Int,
  shots: Int,
  shots_on_goal: Int,
  shots_off_goal: Int,
  shots_blocked: Int,
  shots_in_box: Int,
  shots_out_box: Int,
  corners: Int,
  offsides: Int,
  possession: Float,
  passes: Int,
  passes_completed: Int,
  xg: Float,
  goals_prevented: Int,
  fouls: Int,
  yellow_cards: Int,
  red_cards: Int,
}

struct FixtureStats {
  home: TeamStats,
  away: TeamStats,
}

fn decode_team_stats(entry: Dynamic) TeamStats![decode::Error] {
  let id = try decode::run(entry, decode::path(["team", "id"], decode::int))

  mut passes = 0
  mut passes_completed = 0
  mut shots = 0
  mut shots_on_goal = 0
  mut shots_off_goal = 0
  mut shots_blocked = 0
  mut shots_in_box = 0
  mut shots_out_box = 0
  mut possession = 0.0
  mut xg = 0.0
  mut corners = 0
  mut offsides = 0

  mut fouls = 0
  mut yellow_cards = 0
  mut red_cards = 0
  mut goals_prevented = 0

  // just loop through the statistics and pluck values
  try decode::run(entry, decode::field("statistics", decode::list(fn (data: Dynamic) Void![decode::Error] {
    let name = try decode::run(data, decode::field("type", decode::string))

    let decode_int_value = decode::field("value", fn(data: Dynamic) Int![decode::Error] {
      match decode::is_void(data) {
        true => Result::ok(0),
        false => decode::run(data, decode::int)
      }
    })
    let decode_float_value = decode::field("value", fn(data: Dynamic) Float![decode::Error] {
      let str = try decode::run(data, decode::string)
      let val = Float::from_str(str.replace(old: "%", new: "")).or(0.0)
      Result::ok(val)
    })

    match {
      name == "Total Shots" => { shots = try decode::run(data, decode_int_value) },
      name == "Shots on Goal" => { shots_on_goal = try decode::run(data, decode_int_value) },
      name == "Shots off Goal" => { shots_off_goal = try decode::run(data, decode_int_value) },
      name == "Blocked Shots" => { shots_blocked = try decode::run(data, decode_int_value) },
      name == "Shots insidebox" => { shots_in_box = try decode::run(data, decode_int_value) },
      name == "Shots outsidebox" => { shots_out_box = try decode::run(data, decode_int_value) },
      name == "Fouls" => { fouls = try decode::run(data, decode_int_value) },
      name == "Corner Kicks" => { corners = try decode::run(data, decode_int_value) },
      name == "Offsides" => { offsides = try decode::run(data, decode_int_value) },
      name == "Ball Possession" => { possession = try decode::run(data, decode_float_value) },
      name == "Yellow Cards" => { yellow_cards = try decode::run(data, decode_int_value) },
      name == "Red Cards" => { red_cards = try decode::run(data, decode_int_value) },
      name == "Total passes" => { passes = try decode::run(data, decode_int_value) },
      name == "Passes accurate" => { passes_completed = try decode::run(data, decode_int_value) },
      name == "expected_goals" => { xg = try decode::run(data, decode_float_value) },
      name == "goals_prevented" => { goals_prevented = try decode::run(data, decode_int_value) },
      _ => ()
    }

    Result::ok(())
  })))

  Result::ok(TeamStats{
    id: id,
    passes: passes,
    passes_completed: passes_completed,
    shots: shots,
    shots_blocked: shots_blocked,
    shots_on_goal: shots_on_goal,
    shots_off_goal: shots_off_goal,
    shots_in_box: shots_in_box,
    shots_out_box: shots_out_box,
    offsides: offsides,
    corners: corners,
    possession: possession,
    xg: xg,
    goals_prevented: goals_prevented,
    fouls: fouls,
    yellow_cards: yellow_cards,
    red_cards: red_cards,
  })
}

fn decode_stats(entry: Dynamic) FixtureStats![decode::Error] {
  let teams_stats = try decode::run(entry, decode::field("statistics", decode::list(decode_team_stats)))

  Result::ok(FixtureStats{
    home: teams_stats.at(0),
    away: teams_stats.at(1),
  })
}

fn import_season(db: sql::Database, league_id: Int, season: Int) Void!Str {
  // there are no fixtures saved, so fetch and save them
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err { Result::err("Error fetching fixtures (league={league_id}, season={season}): {err}") }
  let body = try decode::from_json(res.body) -> found { Result::err("Unable to parse response body as JSON (league={league_id}, season={season}). Found {found}") }
  let fixture_ids = try decode::run(body, decode::field("response", decode::list(decode::path(["fixture", "id"], decode::int)))) -> errs {
    Result::err(collapse_errors("Unable to decode ids of fixtures (league={league_id}, season={season})", errs))
  }

  for fixture_id in fixture_ids {
    io::print("Saving fixture={fixture_id}")
    let entry = try fetch(fixture_id) -> err { Result::err("Error fetching fixture (id={fixture_id}): {err}") }

    // fixture info
    let timestamp = try decode::run(entry, decode::path(["fixture", "timestamp"], decode::int)) -> errs { Result::err(collapse_errors("", errs)) }
    let status = try decode::run(entry, decode::path(["fixture", "status", "short"], decode_short_status)) -> errs { Result::err(collapse_errors("", errs)) }
    let home_id = try decode::run(entry, decode::path(["teams", "home", "id"], decode::int)) -> errs { Result::err(collapse_errors("", errs)) }
    let away_id = try decode::run(entry, decode::path(["teams", "away", "id"], decode::int)) -> errs { Result::err(collapse_errors("", errs)) }
    let home_goals = try decode::run(entry, decode::path(["goals", "home"], decode::nullable(decode::int))) -> errs { Result::err(collapse_errors("", errs)) }
    let away_goals = try decode::run(entry, decode::path(["goals", "away"], decode::nullable(decode::int))) -> errs { Result::err(collapse_errors("", errs)) }

    let stats = match status {
      Status::finished => {
        try decode_stats(entry) -> errs { Result::err(collapse_errors("", errs)) }
      },
      _ => {
        let stats = TeamStats{
          id: 0,
          shots: 0,
          shots_on_goal: 0,
          shots_off_goal: 0,
          shots_blocked: 0,
          shots_in_box: 0,
          shots_out_box: 0,
          xg: 0.0,
          possession: 0.0,
          passes: 0,
          passes_completed: 0,
          fouls: 0,
          corners: 0,
          goals_prevented: 0,
          offsides: 0,
          yellow_cards: 0,
          red_cards: 0,
        }
        FixtureStats{ home: stats, away: stats }
      }
    }

    let fixture_values: [Str : sql::Value] = [
      "id": fixture_id,
      "league_id": league_id,
      "season": season,
      "home_id": home_id,
      "away_id": away_id,
      "timestamp": timestamp,
      "status": status.to_str(),
      "home_goals": home_goals.or(0),
      "away_goals": away_goals.or(0),

      "home_shots": stats.home.shots,
      "away_shots": stats.away.shots,
      "home_shots_on_goal": stats.home.shots_on_goal,
      "away_shots_on_goal": stats.away.shots_on_goal,
      "home_shots_blocked": stats.home.shots_blocked,
      "away_shots_blocked": stats.away.shots_blocked,
      "home_shots_in_box": stats.home.shots_in_box,
      "away_shots_in_box": stats.away.shots_in_box,
      "home_shots_out_box": stats.home.shots_out_box,
      "away_shots_out_box": stats.away.shots_out_box,
      "home_possession": stats.home.possession,
      "away_possession": stats.away.possession,
      "home_passes": stats.home.passes,
      "away_passes": stats.away.passes,
      "home_passes_completed": stats.home.passes_completed,
      "away_passes_completed": stats.away.passes_completed,
      "home_fouls": stats.home.fouls,
      "away_fouls": stats.away.fouls,
      "home_corners": stats.home.corners,
      "away_corners": stats.away.corners,
      "home_offsides": stats.home.offsides,
      "away_offsides": stats.away.offsides,
      "home_yellow_cards": stats.home.yellow_cards,
      "away_yellow_cards": stats.away.yellow_cards,
      "home_red_cards": stats.home.red_cards,
      "away_red_cards": stats.away.red_cards,
      "home_xg": stats.home.xg,
      "away_xg": stats.away.xg,
      "home_goals_prevented": stats.home.goals_prevented,
      "away_goals_prevented": stats.away.goals_prevented,
    ]

    try db.query(
      "BEGIN;

      INSERT INTO fixtures (id, league_id, season, home_id, away_id, timestamp, status, home_goals, away_goals)
      VALUES (@id, @league_id, @season, @home_id, @away_id, @timestamp, @status, @home_goals, @away_goals);

      INSERT INTO fixture_stats (
        fixture_id,
        team_id,
        league_id,
        season,
        shots,
        shots_on_goal,
        shots_blocked,
        shots_in_box,
        shots_out_box,
        possession,
        passes,
        passes_completed,
        fouls,
        corners,
        offsides,
        yellow_cards,
        red_cards,
        xg,
        goals_prevented
      )
      VALUES (
        @id,
        @home_id,
        @league_id,
        @season,
        @home_shots,
        @home_shots_on_goal,
        @home_shots_blocked,
        @home_shots_in_box,
        @home_shots_out_box,
        @home_possession,
        @home_passes,
        @home_passes_completed,
        @home_fouls,
        @home_corners,
        @home_offsides,
        @home_yellow_cards,
        @home_red_cards,
        @home_xg,
        @home_goals_prevented,
      );

      INSERT INTO fixture_stats (
        fixture_id,
        team_id,
        league_id,
        season,
        shots,
        shots_on_goal,
        shots_blocked,
        shots_in_box,
        shots_out_box,
        possession,
        passes,
        passes_completed,
        fouls,
        corners,
        offsides,
        yellow_cards,
        red_cards,
        xg,
        goals_prevented
      )
      VALUES (
        @id,
        @away_id,
        @league_id,
        @season,
        @away_shots,
        @away_shots_on_goal,
        @away_shots_blocked,
        @away_shots_in_box,
        @away_shots_out_box,
        @away_possession,
        @away_passes,
        @away_passes_completed,
        @away_fouls,
        @away_corners,
        @away_offsides,
        @away_yellow_cards,
        @away_red_cards,
        @away_xg,
        @away_goals_prevented,
      );

      COMMIT;"
    ).run(fixture_values) -> err { Result::err("Unable to save fixture {fixture_id}: {err}") }

    io::print("Saved fixture={fixture_id}")
  }

  Result::ok(())
}


fn sync_season(db: sql::Database, league_id: Int, season: Int) {
  // check whether there are any fixtures already in the db
  let row = try db.query("SELECT count(*) as count FROM fixtures WHERE league_id = @league_id AND season = @season")
  .first(["league_id": league_id, "season": season]) -> err {
    io::print("Unable to get fixture count for league {league_id} season {season}: {err}")
  }
  let count = try decode::run(row.expect("foobar"), decode::field("count", decode::int)) -> errs {
    io::print("Unable to parse fixture count for league: {league_id} season: {season}: {collapse_errors("", errs)}")
  }

  match count {
    0 => {
      io::print("Importing season for league={league_id}, season={season}")
      match import_season(db: db, league_id: league_id, season: season) {
        ok => (),
        err => {
          // clean up since the import wasn't successful
          // todo: support transactions in ard/sql
          io::print("Failed to import season (league_id={league_id}, season={season}): {err}")
          db.query("BEGIN;
            DELETE FROM fixtures WHERE league_id = @league_id AND season = @season;
            DELETE FROM fixture_stats WHERE league_id = @league_id AND season = @season;
            COMMIT;
          ").run(["league_id": league_id, "season": season])
        }
      }
    },
    // else, look for incomplete fixtures and update them
    1 => {}
  }
}

fn sync(db: sql::Database) {
  let all_leagues = try leagues::get_all(db) -> err { io::print("Unable to get leagues for fixture sync: {err}") }
  for league in all_leagues {
    match leagues::get_current_season(league.id) {
      ok(season) => sync_season(db: db, league_id: league.id, season: season),
      err => io::print("Unable to get current season for league {league.id}: {err}")
    }
  }
}
