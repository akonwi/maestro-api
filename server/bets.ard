use ard/async
use ard/decode
use ard/duration
use ard/io
use ard/sqlite

use maestro/db as _db
use maestro/matches

enum Outcome {
  pending,
  win,
  lose,
  push
}

impl Str::ToString for Outcome {
  fn to_str() Str {
    match @ {
      Outcome::pending => "pending",
      Outcome::win => "win",
      Outcome::lose => "lose",
      Outcome::push => "push"
    }
  }
}

struct Bet {
  id: Int,
  match_id: Int,
  name: Str,
  amount: Float,
  line: Float,
  odds: Int,
  result: Str,
  type_id: Int
}

let decode_id = decode::field("id", decode::int)
let decode_match_id = decode::field("match_id", decode::int)
let decode_type_id = decode::field("type_id", decode::int)
let decode_name = decode::field("name", decode::string)
let decode_amount = decode::field("amount", decode::float)
let decode_line = decode::field("line", decode::float)
let decode_odds = decode::field("odds", decode::int)
let decode_result = decode::field("result", decode::string)

fn decode_bet(data: Dynamic) Bet![decode::Error] {
  let id = try decode_id(data)
  let match_id = try decode_match_id(data)
  let type_id = try decode_type_id(data)
  let name = try decode_name(data)
  let amount = try decode_amount(data)
  let line = try decode_line(data)
  let odds = try decode_odds(data)
  let result = try decode_result(data)

  Result::ok(Bet{
    id: id,
    match_id: match_id,
    type_id: type_id,
    name: name,
    amount: amount,
    line: line,
    odds: odds,
    result: result,
  })
}

fn decode_bets(rows: [Dynamic]) [Bet]!Str {
  mut bets: [Bet] = []
  for row, idx in rows {
    let bet = try decode_bet(row) -> errs { Result::err("Failed to decode row {idx}: {errs.at(0).to_str()}") }
    bets.push(bet)
  }
  Result::ok(bets)
}

fn get_all(db: sqlite::Database) [Bet]!Str {
  let query = db.query("select * from bets")
  let vals: [Str:sqlite::Value] = [:]
  let rows = try query.all(vals)
  decode_bets(rows)
}

fn find_by_match(db: sqlite::Database, match_id: Int) [Bet]!Str {
  let query = db.query("select * from bets where match_id = @match_id")
  let rows = try query.all(["match_id": match_id])
  decode_bets(rows)
}

fn find_by_outcome(db: sqlite::Database, outcome: Outcome) [Bet]!Str {
  let query = db.query("select * from bets where result = @outcome")
  let rows = try query.all(["outcome": outcome.to_str()])
  decode_bets(rows)
}

struct Overview {
  bets: [Bet],
  num_pending: Int,
  total_wagered: Float,
  win_rate: Float,
  gross_payout: Float,
  net_profit: Float,
  gross_loss: Float,
  roi: Float,
}

fn get_overview(db: sqlite::Database) Overview!Str {
  let amount_data = try db.query("SELECT COALESCE(SUM(amount), 0) as value FROM bets").first(["_": 0])
  let total_wagered = match amount_data {
    row => {
      try decode::run(row, decode::field("value", decode::float)) -> errs {
        Result::err("Failed to sum total bet amount: {errs.at(0)}")
      }
    },
    _ => 0.0
  }

  fn get_count(result: [Dynamic]!Str) Int!Str {
    match result {
      ok => Result::ok(ok.size()),
      err => Result::err(err)
    }
  }

  let result_count_query = db.query("SELECT amount, odds FROM bets WHERE result = @result")
  let win_rows = try result_count_query.all(["result": Outcome::win.to_str()])
  let wins = win_rows.size()
  let losses = try get_count(result_count_query.all(["result": Outcome::lose.to_str()]))
  let num_pending = try get_count(result_count_query.all(["result": Outcome::pending.to_str()]))

  fn get_total_payout(rows: [Dynamic]) Float![decode::Error] {
    mut total = 0.0
    for row in rows {
      let amount = try decode_amount(row)
      let odds = try decode_odds(row)

  		// Positive odds: +150 means bet $100 to win $150
  		// Negative odds: -150 means bet $150 to win $100
  		total =+ match odds > 0 {
  		  true => amount + (amount * Float::from_int(odds) / 100.0),
  			false => amount + (amount * 100.0 / Float::from_int(-odds))
  		}
    }

    Result::ok(total)
  }

	let gross_payout = try get_total_payout(win_rows) -> errs {
	  Result::err("Failed to calculate total payout. Expected {errs.at(0).expected}, Got {errs.at(0).found}")
	}

	let gross_amount_query = db.query("SELECT COALESCE(SUM(amount), 0) as value FROM bets WHERE result = @result")
	let loss_amount_data = try gross_amount_query.first(["result": Outcome::lose.to_str()])
	let gross_loss = match loss_amount_data {
	  row => {
			try decode::run(row, decode::field("value", decode::float)) -> errs {
			  Result::err("Failed to decode total loss: {errs.at(0)}")
			}
		},
		_ => 0.0
	}

	let settled = wins + losses
	let net_profit = gross_payout - total_wagered
  let roi = (net_profit/total_wagered) * 100.0

  let bets = try get_all(db)

  Result::ok(Overview{
    bets: bets,
    total_wagered: total_wagered,
    num_pending: num_pending,
    win_rate: (Float::from_int(wins) / Float::from_int(settled)) * 100.0,
    gross_payout: gross_payout,
    gross_loss: gross_loss,
    net_profit: net_profit,
    roi: roi,
  })
}

fn catch(errs: [decode::Error]) Bet!Str {
  io::print("Error parsing bet input: {errs.at(0)}")
  Result::err(message: errs.at(0).to_str())
}

// todo: use a union for the error type - could be bad inputs or db error
fn create(db: sqlite::Database, input: Dynamic) Bet!Str {
  let match_id = try decode_match_id(input) -> catch
  let type_id = try decode_type_id(input) -> catch
  let name = try decode_name(input) -> catch
  let amount = try decode_amount(input) -> catch
  let line = try decode_line(input) -> catch
  let odds = try decode_odds(input) -> catch
  let outcome = Outcome::pending.to_str()

  let insert = db.query("INSERT INTO bets (match_id, type_id, name, amount, line, odds, result) VALUES (@match_id, @type_id, @name, @amount, @line, @odds, @result) RETURNING id")
  let values: [Str:sqlite::Value] = [
    "match_id": match_id,
    "type_id": type_id,
    "name": name,
    "amount": amount,
    "line": line,
    "odds": odds,
    "result": outcome,
  ]
  let row = try insert.first(values)
  let row = try row -> _ { Result::err("Created row not returned") }
  let id = try decode_id(row) -> errs {
    Result::err("Couldn't parse id from created bet row: {errs.at(0)}")
  }

  let bet = Bet{
    id: id,
    type_id: type_id,
    match_id: match_id,
    name: name,
    amount: amount,
    line: line,
    odds: odds,
    result: outcome,
  }

  Result::ok(bet)
}

// currently only supporting changing the result
fn update(db: sqlite::Database, id: Int, input: Dynamic) Void!Str {
  let outcome = try decode_result(input) -> errs {
    Result::err("Invalid input.result: {errs.at(0)}")
  }
  let values: [Str:sqlite::Value] = ["id": id, "outcome": outcome]
  db.query("UPDATE bets SET result = @outcome where id = @id").run(values)
}

fn delete(db: sqlite::Database, id: Int) Void!Str {
  db.query("DELETE FROM bets WHERE id = @id").run(["id": id])
}

fn resolve_team_total(db: sqlite::Database, bet: Bet, goals: Int) Void!Str {
  let outcome = match Float::from_int(goals) > bet.line {
    true => Outcome::win,
    false => Outcome::lose
  }
  let values: [Str:sqlite::Value] = ["id": bet.id, "outcome": outcome.to_str()]
  db.query("UPDATE bets SET result = @outcome where id = @id").run(values)
}

fn resolve_team_cleansheet(db: sqlite::Database, bet: Bet, opp_goals: Int) Void!Str {
  let outcome = match opp_goals {
    0 => Outcome::win,
    _ => Outcome::lose
  }
  let values: [Str:sqlite::Value] = ["id": bet.id, "outcome": outcome.to_str()]
  db.query("UPDATE bets SET result = @outcome where id = @id").run(values)
}

fn resolve_money_line(db: sqlite::Database, bet: Bet, fixture: matches::Match) Void!Str {
  let outcome = match {
    bet.name == "Home" and fixture.home_goals > fixture.away_goals => Outcome::win,
    bet.name == "Away" and fixture.away_goals > fixture.home_goals => Outcome::win,
    _ => Outcome::lose
  }
  let values: [Str:sqlite::Value] = ["id": bet.id, "outcome": outcome.to_str()]
  db.query("UPDATE bets SET result = @outcome where id = @id").run(values)
}

fn process_bet(db: sqlite::Database, bet: Bet) Void!Str {
  let fixture = try matches::get(bet.match_id)
  if fixture.status == "FT" {
    match bet.type_id {
      -1 => (),
      1 => resolve_money_line(db, bet, fixture),
      16 => resolve_team_total(db, bet, fixture.home_goals),
      27 => resolve_team_cleansheet(db, bet, fixture.away_goals),
      17 => resolve_team_total(db, bet, fixture.away_goals),
      28 => resolve_team_cleansheet(db, bet, fixture.home_goals),
      _ => io::print("Unexpected bet type: {bet.type_id}")
    }
  }
  Result::ok(())
}

fn update_outcomes() {
  let db = _db::connect()
  while {
    let bets = try find_by_outcome(db, Outcome::pending) -> err {
      io::print("Error finding pending bets to update: {err}")
    }

    for bet in bets {
      process_bet(db, bet)
    }

    async::sleep(duration::from_minutes(30))
  }
}
