use ard/async
use ard/decode
use ard/duration
use ard/io
use ard/sqlite

use maestro/db as _db
use maestro/matches


enum Outcome {
  pending,
  win,
  lose,
  push
}

impl Str::ToString for Outcome {
  fn to_str() Str {
    match @ {
      Outcome::pending => "pending",
      Outcome::win => "win",
      Outcome::lose => "lose",
      Outcome::push => "push"
    }
  }
}

struct Bet {
  id: Int,
  match_id: Int,
  name: Str,
  amount: Float,
  line: Float,
  odds: Int,
  result: Str,
  type_id: Int
}

let decode_id = decode::field("id", decode::int)
let decode_match_id = decode::field("match_id", decode::int)
let decode_type_id = decode::field("type_id", decode::int)
let decode_name = decode::field("name", decode::string)
let decode_amount = decode::field("amount", decode::float)
let decode_line = decode::field("line", decode::float)
let decode_odds = decode::field("odds", decode::int)
let decode_result = decode::field("result", decode::string)

fn decode_bet(data: Dynamic) Bet![decode::Error] {
  let id = try decode_id(data)
  let match_id = try decode_match_id(data)
  let type_id = try decode_type_id(data)
  let name = try decode_name(data)
  let amount = try decode_amount(data)
  let line = try decode_line(data)
  let odds = try decode_odds(data)
  let result = try decode_result(data)

  Result::ok(Bet{
    id: id,
    match_id: match_id,
    type_id: type_id,
    name: name,
    amount: amount,
    line: line,
    odds: odds,
    result: result,
  })
}

let decode_bets = decode::list(decode_bet)

fn get_all(db: sqlite::Database) [Bet]!Str {
  let rows = try db.query("select * from bets")
  let bets = try decode_bets(rows) -> errs { Result::err(errs.at(0).to_str()) }
  Result::ok(bets)
}

fn find_by_match(db: sqlite::Database, match_id: Int) [Bet]!Str {
  let rows = try db.query("select * from bets where match_id = {match_id}")
  let bets = try decode::run(rows, decode::list(decode_bet)) -> errs { Result::err(errs.at(0).to_str()) }
  Result::ok(bets)
}

struct Overview {
  bets: [Bet],
  num_pending: Int,
  total_wagered: Float,
  win_rate: Float,
  gross_payout: Float,
  net_profit:     Float,
  gross_loss:   Float,
  roi: Float,
}

fn get_overview(db: sqlite::Database) Overview!Str {
  let amount_data = try db.first("SELECT COALESCE(SUM(amount), 0) as value FROM bets")
  let total_wagered = try decode::run(amount_data, decode::field("value", decode::float)) -> errs {
    Result::err("Failed to sum total bet amount: {errs.at(0)}")
  }

  let wins = try db.count("bets", "result = 'win'")
  let losses = try db.count("bets", "result = 'lose'")
  let num_pending = try db.count("bets", "result = 'pending'")

  // Calculate total payout
	let	winning_bet_rows = try db.query("SELECT amount, odds FROM bets WHERE result = 'win'")

	let payouts = try decode::run(winning_bet_rows, decode::list(fn(data: Dynamic) Float![decode::Error] {
	  let amount = try decode::run(data, decode::field("amount", decode::float))
	  let odds = try decode::run(data, decode::field("odds", decode::int))

		// Positive odds: +150 means bet $100 to win $150
		// Negative odds: -150 means bet $150 to win $100
		let payout = match odds > 0 {
		  true => amount + (amount * Float::from_int(odds) / 100.0),
			false => amount + (amount * 100.0 / Float::from_int(-odds))
		}
		Result::ok(payout)
	})) -> errs {
	  Result::err("Failed to calculate total payout. Expected {errs.at(0).expected}, Got {errs.at(0).found}")
	}

	mut gross_payout = 0.0
	for p in payouts {
	  gross_payout =+ p
	}

	// Get total losses (losing bets amount)
	let loss_amount_data = try db.first("SELECT COALESCE(SUM(amount), 0) as value FROM bets WHERE result = 'lose'")
	let gross_loss = try decode::run(loss_amount_data, decode::field("value", decode::float)) -> errs {
	  Result::err("Failed to calculate total loss: {errs.at(0)}")
	}

	let settled = wins + losses
	let net_profit = gross_payout - total_wagered
  let roi = (net_profit/total_wagered) * 100.0

  let bets = try get_all(db)

  Result::ok(Overview{
    bets: bets,
    total_wagered: total_wagered,
    num_pending: num_pending,
    win_rate: (Float::from_int(wins) / Float::from_int(settled)) * 100.0,
    gross_payout: gross_payout,
    gross_loss: gross_loss,
    net_profit: net_profit,
    roi: roi,
  })
}

fn catch(errs: [decode::Error]) Bet!Str {
  io::print("Error parsing bet input: {errs.at(0)}")
  Result::err(message: errs.at(0).to_str())
}

// todo: use a union for the error type - could be bad inputs or db error
fn create(db: sqlite::Database, input: Dynamic) Bet!Str {
  let match_id = try decode_match_id(input) -> catch
  let type_id = try decode_type_id(input) -> catch
  let name = try decode_name(input) -> catch
  let amount = try decode_amount(input) -> catch
  let line = try decode_line(input) -> catch
  let odds = try decode_odds(input) -> catch

  let row = try db.insert(table: "bets", values: [
    "match_id": decode::from_int(match_id),
    "type_id": decode::from_int(type_id),
    "name": decode::from_str(name),
    "amount": decode::from_float(amount),
    "line": decode::from_float(line),
    "odds": decode::from_int(odds),
    "result": decode::from_str("pending"),
  ])
  let id = try decode_id(row) -> errs {
    Result::err("Couldn't parse id from created bet row: {errs.at(0)}")
  }
  let result = try decode::run(row, decode::field("result", decode::string)) -> _ {
    Result::err("Couldn't parse result from created bet row")
  }

  let bet = Bet{
    id: id,
    type_id: type_id,
    match_id: match_id,
    name: name,
    amount: amount,
    line: line,
    odds: odds,
    result: result,
  }

  Result::ok(bet)
}

// currently only supporting changing the result
fn update(db: sqlite::Database, id: Int, input: Dynamic) Void!Str {
  let result = try decode::run(input, decode::field("result", decode::string)) -> errs {
    io::print("Error parsing result to update bet: {errs.at(0)}")
    Result::err(message: errs.at(0).to_str())
  }
  db.exec("update bets set result = '{result}' where id = {id}")
}

fn delete(db: sqlite::Database, id: Int) Bool!Str {
  db.delete("bets", "id = {id}")
}

fn resolve_team_total(db: sqlite::Database, bet: Bet, goals: Int) Void!Str {
  let outcome = match Float::from_int(goals) > bet.line {
    true => Outcome::win,
    false => Outcome::lose
  }
  db.exec("update bets set result = '{outcome}' where id = {bet.id}")
}

fn resolve_team_cleansheet(db: sqlite::Database, bet: Bet, opp_goals: Int) Void!Str {
  let outcome = match opp_goals == 0 {
    true => Outcome::win,
    false => Outcome::lose
  }
  db.exec("update bets set result = '{outcome}' where id = {bet.id}")
}

fn process_bet(db: sqlite::Database, bet: Bet) Void!Str {
  let fixture = try matches::fetch(bet.match_id)
  if fixture.status == "FT" {
    match bet.type_id {
      -1 => (),
      16 => resolve_team_total(db, bet, fixture.home_goals),
      27 => resolve_team_cleansheet(db, bet, fixture.away_goals),
      17 => resolve_team_total(db, bet, fixture.away_goals),
      28 => resolve_team_cleansheet(db, bet, fixture.home_goals),
      _ => io::print("Unexpected bet type: {bet.type_id}")
    }
  }
  Result::ok(())
}

fn update_outcomes() {
  let db = _db::connect()
  while {
    let rows = try db.query("select * from bets where result = '{Outcome::pending}'") -> err {
      io::print("Error finding pending bets to update: {err}")
    }
    let bets = try decode_bets(rows) -> errs {
      io::print("Error decoding pending bets to update: {errs.at(0).to_str()}")
    }

    for bet in bets {
      process_bet(db, bet)
    }

    async::sleep(duration::from_minutes(30))
  }
}
