use ard/decode
use ard/io
use ard/sqlite

struct Bet {
  id: Int,
  match_id: Int,
  name: Str,
  amount: Float,
  line: Float,
  odds: Int,
  result: Str,
}

fn decode_bet(data: Dynamic) Bet![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let match_id = try decode::run(data, decode::field("match_id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let amount = try decode::run(data, decode::field("amount", decode::float))
  let line = try decode::run(data, decode::field("line", decode::float))
  let odds = try decode::run(data, decode::field("odds", decode::int))
  let result = try decode::run(data, decode::field("result", decode::string))

  Result::ok(Bet{
    id: id,
    match_id: match_id,
    name: name,
    amount: amount,
    line: line,
    odds: odds,
    result: result,
  })
}

fn get_all(db: sqlite::Database) [Bet]!Str {
  let rows = try db.query("select * from bets")
  let bets = try decode::run(rows, decode::list(decode_bet)) -> errs { Result::err(errs.at(0).to_str()) }
  Result::ok(bets)
}

fn find_by_match(db: sqlite::Database, match_id: Int) [Bet]!Str {
  let rows = try db.query("select * from bets where match_id = {match_id}")
  let bets = try decode::run(rows, decode::list(decode_bet)) -> errs { Result::err(errs.at(0).to_str()) }
  Result::ok(bets)
}

struct Overview {
  bets: [Bet],
  num_pending: Int,
  total_wagered: Float,
  win_rate: Float,
  gross_payout: Float,
  net_profit:     Float,
  gross_loss:   Float,
  roi: Float,
}

fn get_overview(db: sqlite::Database) Overview!Str {
  let amount_data = try db.first("SELECT COALESCE(SUM(amount), 0) as value FROM bets")
  let total_wagered = try decode::run(amount_data, decode::field("value", decode::float)) -> errs {
    Result::err("Failed to sum total bet amount: {errs.at(0)}")
  }

  let wins = try db.count("bets", "result = 'win'")
  let losses = try db.count("bets", "result = 'lose'")
  let num_pending = try db.count("bets", "result = 'pending'")

  // Calculate total payout
	let	winning_bet_rows = try db.query("SELECT amount, odds FROM bets WHERE result = 'win'")

	let payouts = try decode::run(winning_bet_rows, decode::list(fn(data: Dynamic) Float![decode::Error] {
	  let amount = try decode::run(data, decode::field("amount", decode::float))
	  let odds = try decode::run(data, decode::field("odds", decode::int))

		// Positive odds: +150 means bet $100 to win $150
		// Negative odds: -150 means bet $150 to win $100
		let payout = match odds > 0 {
		  true => amount + (amount * Float::from_int(odds) / 100.0),
			false => amount + (amount * 100.0 / Float::from_int(-odds))
		}
		Result::ok(payout)
	})) -> errs {
	  Result::err("Failed to calculate total payout. Expected {errs.at(0).expected}, Got {errs.at(0).found}")
	}

	mut gross_payout = 0.0
	for p in payouts {
	  gross_payout =+ p
	}

	// Get total losses (losing bets amount)
	let loss_amount_data = try db.first("SELECT COALESCE(SUM(amount), 0) as value FROM bets WHERE result = 'lose'")
	let gross_loss = try decode::run(loss_amount_data, decode::field("value", decode::float)) -> errs {
	  Result::err("Failed to calculate total loss: {errs.at(0)}")
	}

	let settled = wins + losses
	let net_profit = gross_payout - total_wagered
  let roi = (net_profit/total_wagered) * 100.0

  let bets = try get_all(db)

  Result::ok(Overview{
    bets: bets,
    total_wagered: total_wagered,
    num_pending: num_pending,
    win_rate: (Float::from_int(wins) / Float::from_int(settled)) * 100.0,
    gross_payout: gross_payout,
    gross_loss: gross_loss,
    net_profit: net_profit,
    roi: roi,
  })
}

fn catch(errs: [decode::Error]) Bet!Str {
  // todo: Decode::Error.pretty_path()
  io::print("Error parsing bet input: {errs.at(0)}")
  Result::err(message: errs.at(0).to_str())
}

// todo: use a union for the error type - could be bad inputs or db error
fn create(db: sqlite::Database, input: Dynamic) Bet!Str {
  let match_id = try decode::run(input, decode::field("match_id", decode::int)) -> catch
  let name = try decode::run(input, decode::field("name", decode::string)) -> catch
  let amount = try decode::run(input, decode::field("amount", decode::float)) -> catch
  let line = try decode::run(input, decode::field("line", decode::float)) -> catch
  let odds = try decode::run(input, decode::field("odds", decode::int)) -> catch

  let row = try db.insert(table: "bets", values: [
    "match_id": decode::from_int(match_id),
    "name": decode::from_str(name),
    "amount": decode::from_float(amount),
    "line": decode::from_float(line),
    "odds": decode::from_int(odds),
    "result": decode::from_str("pending"),
  ])
  let id = try decode::run(row, decode::field("id", decode::int)) -> _ {
    Result::err("Couldn't parse id from created bet row")
  }
  let result = try decode::run(row, decode::field("result", decode::string)) -> _ {
    Result::err("Couldn't parse result from created bet row")
  }

  let bet = Bet{
    id: id,
    match_id: match_id,
    name: name,
    amount: amount,
    line: line,
    odds: odds,
    result: result,
  }

  Result::ok(bet)
}

// currently only supporting changing the result
fn update(db: sqlite::Database, id: Int, input: Dynamic) Void!Str {
  let result = try decode::run(input, decode::field("result", decode::string)) -> errs {
    io::print("Error parsing result to update bet: {errs.at(0)}")
    Result::err(message: errs.at(0).to_str())
  }
  db.exec("update bets set result = '{result}' where id = {id}")
}

fn delete(db: sqlite::Database, id: Int) Bool!Str {
  db.delete("bets", "id = {id}")
}
