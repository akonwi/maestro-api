use ard/dates
use ard/decode
use ard/env
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

use maestro/config

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league_id: Int,
  status: Str,
  home_team_id: Int,
  away_team_id: Int,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

fn decode_match(row: Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let date = try decode::run(row, decode::field("date", decode::string))
  let timestamp = try decode::run(row, decode::field("timestamp", decode::int))
  let league_id = try decode::run(row, decode::field("league_id", decode::int))
  let status = try decode::run(row, decode::field("status", decode::string))
  let home_team_id = try decode::run(row, decode::field("home_team_id", decode::int))
  let away_team_id = try decode::run(row, decode::field("away_team_id", decode::int))
  let home_goals = try decode::run(row, decode::field("home_goals", decode::int))
  let away_goals = try decode::run(row, decode::field("away_goals", decode::int))
  let winner_id = try decode::run(row, decode::field("winner_id", decode::nullable(decode::int)))

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    away_team_id: away_team_id,
    home_goals: home_goals,
    away_goals: away_goals,
    winner_id: winner_id,
  })
}

// fixtures come from API-Football
fn decode_fixture_entry(row: Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("fixture", decode::field("id", decode::int)))
  let date = try decode::run(row, decode::field("fixture", decode::field("date", decode::string)))
  let timestamp = try decode::run(row, decode::field("fixture", decode::field("timestamp", decode::int)))
  let status = try decode::run(row, decode::field("fixture", decode::field("status", decode::field("short", decode::string))))
  let league_id = try decode::run(row, decode::field("league", decode::field("id", decode::int)))
  let home_team_id = try decode::run(row, decode::field("teams", decode::field("home", decode::field("id", decode::int))))
  let away_team_id = try decode::run(row, decode::field("teams", decode::field("away", decode::field("id", decode::int))))
  let is_home_win = try decode::run(row, decode::field("teams", decode::field("home", decode::field("winner", decode::nullable(decode::bool)))))
  let is_away_win = try decode::run(row, decode::field("teams", decode::field("away", decode::field("winner", decode::nullable(decode::bool)))))
  let home_goals = try decode::run(row, decode::field("goals", decode::field("home", decode::nullable(decode::int))))
  let away_goals = try decode::run(row, decode::field("goals", decode::field("away", decode::nullable(decode::int))))

  let winner_id: Int? = match is_home_win.or(false) {
    true => maybe::some(home_team_id),
    false => {
      match is_away_win.or(false) {
        true => maybe::some(away_team_id),
        false => maybe::none()
      }
    }
  }

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    away_team_id: away_team_id,
    home_goals: home_goals.or(0),
    away_goals: away_goals.or(0),
    winner_id: winner_id,
  })
}

fn fetch_season(league_id: Int, season: Int) [Match] {
  let api_key = match env::get("API_KEY") {
    key => key,
    _ => panic("API_KEY environment variable not set")
  }
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={season}",
    headers: [
      "x-rapidapi-key": api_key,
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err {
    io::print("Error fetching fixtures: {err}")
    List::new<Match>()
  }

  let body = decode::json(res.body)
  try decode::run(body, decode::field("response", decode::list(decode_fixture_entry))) -> errs {
    io::print("Error decoding body.response: {errs.at(0)}")
    List::new<Match>()
  }
}

// turn into values for the database
fn to_values(m: Match) [Str:Dynamic] {
  mut values: [Str: Dynamic] = [
    "id": decode::from_int(m.id),
    "date": decode::from_str(m.date),
    "timestamp": decode::from_int(m.timestamp),
    "league_id": decode::from_int(m.league_id),
    "status": decode::from_str(m.status),
    "home_team_id": decode::from_int(m.home_team_id),
    "away_team_id": decode::from_int(m.away_team_id),
    "home_goals": decode::from_int(m.home_goals),
    "away_goals": decode::from_int(m.away_goals),
  ]

  match m.winner_id {
    id => values.set("winner_id", decode::from_int(id)),
    _ => {},
  }

  values
}

// EPL, Championship, MLS
let league_ids = [39,40,253]
let season = 2025

// update the matches in the db
fn sync(db: sqlite::Database) {
  for id in league_ids {
    for m in fetch_season(id, season) {
      let exists = db.exists("matches", "id = {m.id}").expect("Error checking for match in db")
      if exists {
        match db.update("matches", "id={m.id}", to_values(m)) {
          err => io::print("Error updating match({m.id}): {err}"),
          ok => {},
        }
      } else {
        match db.insert("matches", to_values(m)) {
          err => io::print("Error inserting match({m.id}): {err}"),
          ok => {},
        }
      }
    }

    io::print("Updated match data for league {id}")
  }
}

fn get_league(db: sqlite::Database, league_id: Int) [Match]!Str {
  let rows = try db.query("select * from matches where league_id = {league_id} order by timestamp desc")
  let matches = try decode::run(rows, decode::list(decode_match)) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(matches)
}

private fn ints_to_str(ints: [Int]) Str {
  mut str = ""
  for int, idx in ints {
    if idx == 0 {
      str = int.to_str()
    } else {
      str = "{str},{int}"
    }
  }
  str
}

fn find(db: sqlite::Database, ids: [Int]) [Match]!Str {
  let rows = try db.query("select * from matches where id in ({ints_to_str(ids)});")
  let matches = try decode::run(rows, decode::list(decode_match)) -> errors {
    Result::err(errors.at(0).to_str())
  }
  Result::ok(matches)
}

fn get(db: sqlite::Database, id: Int) Match!Str {
  let row = try db.first("select * from matches where id = {id};")
  let found = try decode::run(row, decode_match) -> errors {
    Result::err(errors.at(0).to_str())
  }
  Result::ok(found)
}

struct Team {
  id: Int,
  name: Str,
  logo: Str?
}

struct Fixture {
  id: Int,
  date: Str,
  timestamp: Int,

  league_id: Int,
  league_name: Str,
  season: Int,

  home: Team,
  away: Team,
}

fn decode_team(row: Dynamic) Team![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let name = try decode::run(row, decode::field("name", decode::string))
  let logo = try decode::run(row, decode::field("logo", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    name: name,
    logo: logo,
  })
}

fn decode_fixture(row: Dynamic) Fixture![decode::Error] {
  let id = try decode::run(row, decode::field("fixture", decode::field("id", decode::int)))
  let date = try decode::run(row, decode::field("fixture", decode::field("date", decode::string)))
  let timestamp = try decode::run(row, decode::field("fixture", decode::field("timestamp", decode::int)))
  let league_id = try decode::run(row, decode::field("league", decode::field("id", decode::int)))
  let league_name = try decode::run(row, decode::field("league", decode::field("name", decode::string)))
  let league_season = try decode::run(row, decode::field("league", decode::field("season", decode::int)))
  let home = try decode::run(row, decode::field("teams", decode::field("home", decode_team)))
  let away = try decode::run(row, decode::field("teams", decode::field("away", decode_team)))

  Result::ok(Fixture{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    league_name: league_name,
    season: league_season,
    home: home,
    away: away,
  })
}

fn find_today() [Fixture] {
  let today = dates::get_today()
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?status=NS&timezone=America/New_York&date={today}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err {
    io::print("Error fetching today's fixtures: {err}")
    List::new<Fixture>()
  }

  // todo: follow paginations
  let body = decode::json(res.body)
  try decode::run(body, decode::field("response", decode::list(decode_fixture))) -> errs {
    io::print("Error decoding body.response: {errs.at(0)}")
    List::new<Fixture>()
  }
}
