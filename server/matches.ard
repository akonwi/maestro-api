use ard/dates
use ard/decode
use ard/env
use ard/http
use ard/io
use ard/maybe
use ard/sqlite

use maestro/config

let SEASON = 2025

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league_id: Int,
  status: Str,
  home_team_id: Int,
  home_team_name: Str,
  away_team_id: Int,
  away_team_name: Str,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

fn decode_match(row: Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let date = try decode::run(row, decode::field("date", decode::string))
  let timestamp = try decode::run(row, decode::field("timestamp", decode::int))
  let league_id = try decode::run(row, decode::field("league_id", decode::int))
  let status = try decode::run(row, decode::field("status", decode::string))
  let home_team_id = try decode::run(row, decode::field("home_team_id", decode::int))
  let away_team_id = try decode::run(row, decode::field("away_team_id", decode::int))
  let home_goals = try decode::run(row, decode::field("home_goals", decode::int))
  let away_goals = try decode::run(row, decode::field("away_goals", decode::int))
  let winner_id = try decode::run(row, decode::field("winner_id", decode::nullable(decode::int)))

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    home_team_name: "",
    away_team_id: away_team_id,
    away_team_name: "",
    home_goals: home_goals,
    away_goals: away_goals,
    winner_id: winner_id,
  })
}

// fixtures come from API-Football
fn decode_fixture_entry(row: Dynamic) Match![decode::Error] {
  let id = try decode::run(row, decode::field("fixture", decode::field("id", decode::int)))
  let date = try decode::run(row, decode::field("fixture", decode::field("date", decode::string)))
  let timestamp = try decode::run(row, decode::field("fixture", decode::field("timestamp", decode::int)))
  let status = try decode::run(row, decode::field("fixture", decode::field("status", decode::field("short", decode::string))))
  let league_id = try decode::run(row, decode::field("league", decode::field("id", decode::int)))
  let home_team_id = try decode::run(row, decode::field("teams", decode::field("home", decode::field("id", decode::int))))
  let home_team_name = try decode::run(row, decode::path(["teams", "home", "name"], decode::string))
  let away_team_id = try decode::run(row, decode::field("teams", decode::field("away", decode::field("id", decode::int))))
  let away_team_name = try decode::run(row, decode::path(["teams", "away", "name"], decode::string))
  let is_home_win = try decode::run(row, decode::field("teams", decode::field("home", decode::field("winner", decode::nullable(decode::bool)))))
  let is_away_win = try decode::run(row, decode::field("teams", decode::field("away", decode::field("winner", decode::nullable(decode::bool)))))
  let home_goals = try decode::run(row, decode::field("goals", decode::field("home", decode::nullable(decode::int))))
  let away_goals = try decode::run(row, decode::field("goals", decode::field("away", decode::nullable(decode::int))))

  let winner_id: Int? = match is_home_win.or(false) {
    true => maybe::some(home_team_id),
    false => {
      match is_away_win.or(false) {
        true => maybe::some(away_team_id),
        false => maybe::none()
      }
    }
  }

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    status: status,
    home_team_id: home_team_id,
    home_team_name: home_team_name,
    away_team_id: away_team_id,
    away_team_name: away_team_name,
    home_goals: home_goals.or(0),
    away_goals: away_goals.or(0),
    winner_id: winner_id,
  })
}

fn fetch_season(league_id: Int) [Match]!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={SEASON}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err { Result::err("Error fetching fixtures: {err}") }
  let body = try decode::from_json(res.body) -> found { Result::err("Unable to parse response body as JSON. Found {found}") }

  let fixtures = try decode::run(body, decode::field("response", decode::list(decode_fixture_entry))) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(fixtures)
}

// turn into values for the database
fn to_values(m: Match) [Str:Dynamic] {
  mut values: [Str: Dynamic] = [
    "id": decode::from_int(m.id),
    "date": decode::from_str(m.date),
    "timestamp": decode::from_int(m.timestamp),
    "league_id": decode::from_int(m.league_id),
    "status": decode::from_str(m.status),
    "home_team_id": decode::from_int(m.home_team_id),
    "away_team_id": decode::from_int(m.away_team_id),
    "home_goals": decode::from_int(m.home_goals),
    "away_goals": decode::from_int(m.away_goals),
  ]

  match m.winner_id {
    id => values.set("winner_id", decode::from_int(id)),
    _ => {},
  }

  values
}

private fn ints_to_str(ints: [Int]) Str {
  mut str = ""
  for int, idx in ints {
    if idx == 0 {
      str = int.to_str()
    } else {
      str = "{str},{int}"
    }
  }
  str
}

fn get(id: Int) Match!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?id={id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req)
  let body = try decode::from_json(res.body)
  let count = try decode::run(body, decode::field("results", decode::int)) -> errs {
    Result::err(errs.at(0).to_str())
  }

  match count {
    1 => {
      let fixture = try decode::run(body, decode::field("response", decode::at(0, decode_fixture_entry))) -> errs {
        Result::err(errs.at(0).to_str())
      }
      Result::ok(fixture)
    },
    _ => Result::err("Found {count} fixtures for id {id}")
  }
}

struct Team {
  id: Int,
  name: Str,
  logo: Str?
}

struct Fixture {
  id: Int,
  date: Str,
  timestamp: Int,

  league_id: Int,
  league_name: Str,
  season: Int,

  home: Team,
  away: Team,
}

fn decode_team(row: Dynamic) Team![decode::Error] {
  let id = try decode::run(row, decode::field("id", decode::int))
  let name = try decode::run(row, decode::field("name", decode::string))
  let logo = try decode::run(row, decode::field("logo", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    name: name,
    logo: logo,
  })
}

fn decode_fixture(row: Dynamic) Fixture![decode::Error] {
  let id = try decode::run(row, decode::field("fixture", decode::field("id", decode::int)))
  let date = try decode::run(row, decode::field("fixture", decode::field("date", decode::string)))
  let timestamp = try decode::run(row, decode::field("fixture", decode::field("timestamp", decode::int)))
  let league_id = try decode::run(row, decode::field("league", decode::field("id", decode::int)))
  let league_name = try decode::run(row, decode::field("league", decode::field("name", decode::string)))
  let league_season = try decode::run(row, decode::field("league", decode::field("season", decode::int)))
  let home = try decode::run(row, decode::field("teams", decode::field("home", decode_team)))
  let away = try decode::run(row, decode::field("teams", decode::field("away", decode_team)))

  Result::ok(Fixture{
    id: id,
    date: date,
    timestamp: timestamp,
    league_id: league_id,
    league_name: league_name,
    season: league_season,
    home: home,
    away: away,
  })
}

fn find_today() [Fixture] {
  let today = dates::get_today()
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?status=NS&timezone=America/New_York&date={today}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err {
    io::print("Error fetching today's fixtures: {err}")
    List::new<Fixture>()
  }

  // todo: follow paginations
  let body = decode::json(res.body)
  try decode::run(body, decode::field("response", decode::list(decode_fixture))) -> errs {
    io::print("Error decoding body.response: {errs.at(0)}")
    List::new<Fixture>()
  }
}
