use ard/dates
use ard/decode
use ard/env
use ard/http
use ard/io
use ard/maybe

use maestro/config

let SEASON = 2025

struct Team {
  id: Int,
  name: Str,
  logo: Str?
}

fn decode_team(data: Dynamic) Team![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let logo = try decode::run(data, decode::field("logo", decode::nullable(decode::string)))

  Result::ok(Team{
    id: id,
    name: name,
    logo: logo,
  })
}

struct League {
  id: Int,
  name: Str,
  season: Int,
}

fn decode_league(data: Dynamic) League![decode::Error] {
  let id = try decode::run(data, decode::field("id", decode::int))
  let name = try decode::run(data, decode::field("name", decode::string))
  let season = try decode::run(data, decode::field("season", decode::int))

  Result::ok(League{
    id: id,
    name: name,
    season: season,
  })
}

struct Match {
  id: Int,
  date: Str,
  timestamp: Int,
  league: League,
  status: Str,
  home: Team,
  away: Team,
  home_goals: Int,
  away_goals: Int,
  winner_id: Int?,
}

// fixtures come from API-Football
fn decode_fixture_entry(data: Dynamic) Match![decode::Error] {
  let id = try decode::run(data, decode::path(["fixture", "id"], decode::int))
  let date = try decode::run(data, decode::path(["fixture", "date"], decode::string))
  let timestamp = try decode::run(data, decode::path(["fixture", "timestamp"], decode::int))
  let status = try decode::run(data, decode::path(["fixture", "status", "short"], decode::string))
  let league = try decode::run(data, decode::field("league", decode_league))
  let home = try decode::run(data, decode::path(["teams", "home"], decode_team))
  let away = try decode::run(data, decode::path(["teams", "away"], decode_team))
  let is_home_win = try decode::run(data, decode::path(["teams", "home", "winner"], decode::nullable(decode::bool)))
  let is_away_win = try decode::run(data, decode::path(["teams", "away", "winner"], decode::nullable(decode::bool)))
  let home_goals = try decode::run(data, decode::path(["goals", "home"], decode::nullable(decode::int)))
  let away_goals = try decode::run(data, decode::path(["goals", "away"], decode::nullable(decode::int)))

  let winner_id: Int? = match is_home_win.or(false) {
    true => maybe::some(home.id),
    false => {
      match is_away_win.or(false) {
        true => maybe::some(away.id),
        false => maybe::none()
      }
    }
  }

  Result::ok(Match{
    id: id,
    date: date,
    timestamp: timestamp,
    league: league,
    status: status,
    home: home,
    away: away,
    home_goals: home_goals.or(0),
    away_goals: away_goals.or(0),
    winner_id: winner_id,
  })
}

fn get_season(league_id: Int) [Match]!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?league={league_id}&season={SEASON}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err { Result::err("Error fetching fixtures: {err}") }
  let body = try decode::from_json(res.body) -> found { Result::err("Unable to parse response body as JSON. Found {found}") }

  let fixtures = try decode::run(body, decode::field("response", decode::list(decode_fixture_entry))) -> errs {
    Result::err(errs.at(0).to_str())
  }
  Result::ok(fixtures)
}

fn get(id: Int) Match!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?id={id}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req)
  let body = try decode::from_json(res.body)
  let count = try decode::run(body, decode::field("results", decode::int)) -> errs {
    Result::err(errs.at(0).to_str())
  }

  match count {
    1 => {
      let fixture = try decode::run(body, decode::field("response", decode::at(0, decode_fixture_entry))) -> errs {
        Result::err(errs.at(0).to_str())
      }
      Result::ok(fixture)
    },
    _ => Result::err("Found {count} fixtures for id {id}")
  }
}

fn find_today() [Match] {
  let today = dates::get_today()
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/fixtures?status=NS&timezone=America/New_York&date={today}",
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err {
    io::print("Error fetching today's fixtures: {err}")
    List::new<Match>()
  }

  // todo: follow paginations
  match decode::from_json(res.body) {
    ok(body) => {
      try decode::run(body, decode::field("response", decode::list(decode_fixture_entry))) -> errs {
        io::print("Error decoding body.response: {errs.at(0)}")
        List::new<Match>()
      }
    },
    err => List::new<Match>()
  }
}
