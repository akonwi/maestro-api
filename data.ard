use ard/async
use ard/http
use ard/io
use ard/sqlite
use ard/maybe

use maestro/duration
use maestro/teams
use maestro/matches

struct League {
  id: Int,
  name: Str,
  code: Str,
}

fn get_teams(db: sqlite::Database, leagues: [League]) {
  for league in leagues {
    io::print("Fetching teams for {league.name}")
    for team in teams::fetch(league.id, 2025) {
      match db.exists("teams", "id = {team.id}").or(false) {
        true => {},
        false => {
          match db.insert("teams", team) {
            err => io::print("Failed to insert {team.name}"),
            ok(_) => io::print("Saved {team.name}")
          }
        }
      }
    }
  }
}

fn main() {
  let db = sqlite::open("./db.sqlite").expect("Failed to open database")

  db.exec("create table if not exists leagues (id INTEGER PRIMARY KEY, name TEXT, code TEXT)")
    .expect("Failed to create leagues table")
  db.exec("create table if not exists seasons (id INTEGER PRIMARY KEY, name TEXT, code TEXT)")
    .expect("Failed to create seasons table")
  db.exec("create table if not exists teams (id INTEGER PRIMARY KEY, name TEXT, code TEXT, league_id INTEGER)")
    .expect("Failed to create teams table")

  // let leagues = db.get<League>("leagues", "").expect("Failed to get leagues")
  // get_teams(db, leagues)

  // mut league_ids: [Int] = []
  // for league in leagues {
  //   league_ids.push(league.id)
  // }
  // matches::seed(db, league_ids)

  // update data in the background
  let syncWorker = async::start(fn() {
    while {
      // do stuff
      async::sleep(duration::from_seconds(3))
    }
  })
  // block current fiber until syncWorker ends
  syncWorker.join()

  db.close().expect("Failed to close database")
}
